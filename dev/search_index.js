var documenterSearchIndex = {"docs":
[{"location":"FDIObjects.html#Building-fault-detection-and-isolation-related-objects","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"","category":"section"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel  Falt detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDFilterIF  Fault detection filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.","category":"page"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel\nfdimodset\nFDFilter\nFDFilter(::DescriptorSystems.DescriptorStateSpace, ::Int, ::Int)\nFDFilterIF\nFDFilterIF(::DescriptorSystems.DescriptorStateSpace, ::Int, ::Int, ::Int)","category":"page"},{"location":"FDIObjects.html#FaultDetectionTools.FDIModel","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIModel","text":"FDIModel <: AbstractDescriptorStateSpace\n\nType for synthesis models employed to solve fault detection and isolation problems.\n\nIf sysf::FDIModel is the synthesis model object, the underlying descriptor system model can be obtained via sysf.sys and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in sysf.controls, sysf.disturbances, sysf.faults,  sysf.noise and sysf.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.fdimodset","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.fdimodset","text":"fdimodset(sys; controls, c, disturbances, d, faults, f, fa, faults_sen, fs, noise, n, aux) -> sysf::FDIModel\n\nBuild for a given linear time-invariant system model sys = (A-λE,B,C,D), a synthesis model object sysf  to be used in conjunction with the analysis and synthesis functions of FDI filters.  The information on the partition of the input components in control, disturbance, fault, noise and auxiliary inputs can be specified using the following keyword arguments:\n\ncontrols = inpu or c = inpu specifies the indices inpu of the control inputs (default: void)\n\ndisturbances = inpd or d = inpd specifies the indices inpd of the disturbance inputs (default: void)\n\nfaults = inpf or f  = inpf specifies the indices inpf of the fault inputs (default: void)\n\nfa = inpfa specifies the indices inpfa of control inputs subject to actuator fault (default: void)\n\nfaults_sen = inpfs or fs = inpfs specifies the indices inpfs of the system outputs subject to sensor fault inputs (default: void)\n\nnoise = inpn or  noise = inpn specifies the indices inpn of the noise inputs (default: void)\n\naux = inpa specifies the indices inpa of the auxiliary inputs (default: void)\n\nThe indices of inputs or outputs can be specified as integer vectors, integer scalars or integer UnitRanges.\n\nThe resulting sysf contains the partitioned system  sysf.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]), where  Bu, Bd, Bf, Bw and Bv are the input matrices from the control inputs u, disturbance inputs d, fault inputs f,  noise inputs w and auxiliary inputs v, respectively, and Du, Dd, Df, Dw and Dv are the feedthrough matrices from those inputs. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nMethod: If G(λ) is the p x m transfer function matrix of sys, then the resulting system sysf has an  equivalent input output form [Gu(λ) Gd(λ) Gf(λ) Gw(λ) Gv(λ)], where the following relations define the component matrices: Gu(λ) = G(λ)*Su, Gd(λ) = G(λ)*Sd,  Gf(λ) = [G(λ)*Sf Ss], Gw(λ) = G(λ)*Sw,  Gv(λ) = G(λ)*Sv, with the selection matrices Su, Sd, Sf, Sw and Sv formed from the columns of the m-th order identity matrix and  Ss is formed  from the columns of the p-th order identity matrix. \n\n\n\n\n\n","category":"function"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter <: AbstractDescriptorStateSpace\n\nType for fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilter is the fault detection filter object, the underlying descriptor system model can be obtained via filter.sys and the indices of output and control inputs  can be accessed as the integer vectors  contained in filter.outputs and filter.controls, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter-Tuple{DescriptorStateSpace, Int64, Int64}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter(sys, p, mu) -> Q::FDFilter\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter object Q, as determined with the synthesis functions of FDI filters.  p and mu are the number of measured outputs and the number of control inputs, respectively.  It is assumed that B = [By Bu Bv] and D = [Dy Du Dv] are partitioned matrices such that By and Dy have p columns, and Bu and Du have mu columns,  where By and Bu are the input matrices from the measured outputs y and  control inputs u, Dy and Du are the feedthrough matrices from the measured outputs y and  control inputs u. \n\nThe resulting Q contains the partitioned system  Q.sys = (A-λE,[By Bd],C,[Dy Du]) and the indices of inputs corresponding  to the measured outputs and control inputs are contained in the associated  integer vectors Q.outputs and Q.controls. \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF <: AbstractDescriptorStateSpace\n\nType for the internal form of fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilterIF is the fault detection filter internal form object,  the underlying descriptor system model can be obtained via filter.sys and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in filter.controls, filter.disturbances, filter.faults,  filter.noise and filter.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF-Tuple{DescriptorStateSpace, Int64, Int64, Int64}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF(sys, mu, md, mf, mw = 0, maux = 0; moff = 0 ) -> R::FDFilterIF\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter internal form object R, as determined with the synthesis functions of FDI filters.  mu, md, mf, mw and maux are the dimensions of control, disturbance, fault, noise and auxiliary input vectors, respectively. It is assumed that B = [Boff Bu Bd Bf Bw Bv] and D = [Doff Du Dd Df Dw Dv] are partitioned matrices such that Boff and Doff have moff columns, Bu and Du have mu columns, Bd and Dd have md columns,  Bf and Df have mf columns,  Bw and Dw have mw columns, and Bv and Dv have maux columns.   \n\nThe resulting R contains the partitioned system  R.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]) and the indices of inputs corresponding  to the control, disturbance, fault, noise and auxiliary inputs are contained in the associated  integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux.  \n\n\n\n\n\n","category":"method"},{"location":"FDIperformance.html#Performance-evaluation-of-FDI-filters","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"","category":"section"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdscond  Computation of the fault detection sensitivity condition.","category":"page"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec\nfdisspec\nfdscond","category":"page"},{"location":"FDIperformance.html#FaultDetectionTools.fditspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fditspec","text":"S = fditspec(sysrf; FDfreq = missing, block = false, FDtol, FDStol, \n                    atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the transfer function matrix of a  linear time-invariant system sysrf  (typically representing the transfer channel from the fault inputs to residuals). sysrf is either a descriptor system representation sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ) or can be a fault detection filter internal form object sysrf::FDFilterIF, in which case  only the fault inputs channel sysrf.sys[:,sysrf.faults] := (Af-lambda*Ef,Bf,Cf,Df) is selected. \n\nIf FDfreq = missing (default), then S contains the weak structure matrix of Rf(λ).  For block = false, S is determined as a q x mf  binary matrix (BitMatrix), whose (i,j)-th element is S[i,j] = 1, if the (i,j)-th element of Rf(λ) is  nonzero, and otherwise, S[i,j] = 0.  For block = true, S is determined as a 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of Rf(λ) is nonzero, and otherwise, S[1,j] = 0. \n\nIf FDfreq = freq specifies a vector freq of nf real frequencies  which characterize the classes of persistent fault signals, then S contains the strong  structure matrix of Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system sysrf, or λ := exp(im*f*abs(Ts)), for a discrete-time system sysfr with sampling-time Ts.   For block = false, S is determined as a q x mf x nf  binary matrix, whose (i,j,k)-th element is S[i,j,k] = 1, if the (i,j)-th element of Rf(λ) is  nonzero for the k-th frequency in freq, and otherwise, S[i,j,k] = 0.  For block = true, S is determined as a 1 x mf x nf binary matrix, whose (1,j,k)-th element is S[1,j,k] = 1,  if the j-th column of Rf(λ) is nonzero for the k-th frequency in FDfreq, and otherwise, S[1,j,k] = 0. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nFDtol = tol1 specifies an absolute threshold tol1 for the magnitudes of nonzero elements in the system matrices  Bf and Df and is used to determine the weak structure matrix.  Its default value is tol1 = 0.0001*max(1, norm(Bf,1), norm(Df,1)). \n\nFDStol = tol2 specifies an absolute  threshold tol2 for the magnitudes of nonzero elements in the system matrices  Af, Ef, Bf, Cf and Df and is used to determine the strong structure matrix.  Its default value is  tol2 = epsm*max(1, norm(Ef,1), norm(Af,1), norm(Bf,1), norm(Cf,Inf), norm(Df,1))),  where epsm is the working machine precision.\n\nMethod: For the definition of the structure matrix, see [1]. For the determination of the weak structure matrix, minimal realizations are determined for each column of Rf(λ) if block = true or for  each element of Rf(λ) if block = false and the nonzero columns or  elements in each column are identified  (see Corollary 7.1 of [1]). For the determination of the strong structure matrix, minimal realizations are determined for each column of Rf(λ) if block = true or for  each element of Rf(λ) if block = false and  the full rank of the corresponding system matrix is checked for all frequencies in FDfreq (see Corollary 7.2 in [1]) (i.e., the lack of zeros in all frequencies).\n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec.3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdisspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdisspec","text":" fdisspec(sysrf, freq; block = false, FDGainTol = 0.01, \n                 atol = 0, atol1 = 0, atol2 = 0, rtol = 0, fast = true) -> (S, gains)\n\nCompute for the linear time-invariant system sysrf and  a given set of real frequencies freq,   the strong binary structure matrix S of the transfer function matrix of sysrf  and the corresponding frequency response gains gains.  sysrf typically represents the transfer channel from the fault inputs to residuals and is either a descriptor system representation sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ) or is a fault detection filter internal form object sysrf::FDFilterIF, in which case  only the fault inputs channel sysrf.sys[:,sysrf.faults] := (Af-lambda*Ef,Bf,Cf,Df) is selected. \n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent fault signals  (default: freq = 0, i.e., characterizing constant faults). S contains the strong  structure matrix of Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system sysrf, or λ := exp(im*f*abs(Ts)), for a discrete-time system sysfr with sampling-time Ts.   If any of the frequency values in freq is a pole of sysf, then sysf is replaced by the stable numerator  of a left coprime factorization of sysf. \n\nFDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nFor block = false, gains is a p x mf x nf matrix, whose (i,j,k)-th element is the magnitude of the  (i,j)-th element of Rf(λ) evaluated for the k-th frequency in freq.  S is determined as a q x mf x nf  binary matrix, whose (i,j,k)-th element is S[i,j,k] = 1, if the (i,j,k)-th element of gains is  is larger then or equal to tol, and otherwise, S[i,j,k] = 0.  For block = true, gains is an 1 x mf x nf matrix, whose (1,j,k)-th element is the norm of the  j-th column of Rf(λ) evaluated for the k-th frequency in freq. S is determined as an 1 x mf x nf binary matrix, whose (1,j,k)-th element is S[1,j,k] = 1,  if the (1,j,k)-th element of gains is larger then or equal to tol  and otherwise, S[1,j,k] = 0. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nMethod: S is evaluated using the definition of the strong structure matrix in [1]. \n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec. 3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdscond","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdscond","text":" fdscond(sysf,freq) -> (scond, β, γ)\n\nCompute for a stable descriptor system sysf = (A-λE,B,C,D) with the transfer function matrix Rf(λ),  β - the H∞- index of Rf(λ), γ - the maximum of the columns norms of Rf(λ) and  the fault detection sensitivity condition scond evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq.  If sysf is a fault detection filter internal form object sysf::FDFilterIF then scond, β and γ are evaluated only for the fault inputs channel sysf.sys[:,sysf.faults]. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FDI-related-utilities","page":"FDI related utilities","title":"FDI related utilities","text":"","category":"section"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdIFeval  Evaluation of the internal form of a fault detection filter. \nfdhinfminus  Evaluation of the H∞- index.  \nfdhinfmax  Evaluation of the maximum of column norm.  ","category":"page"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdIFeval\nfdhinfminus\nfdhinfmax","category":"page"},{"location":"FDIutils.html#FaultDetectionTools.fdIFeval","page":"FDI related utilities","title":"FaultDetectionTools.fdIFeval","text":"fdIFeval(sysQ::FDFilter, sysf::FDIModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::FDFilterIF\n\nCompute the internal form sysR of the fault detection filter sysQ applied to the synthesis model sysf.  If sysf has the partitioned transfer function matrix G(λ) = [ Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) ] in accordance with the partitioned system inputs as controls, disturbances, faults, noise and auxiliary inputs, respectively, and Q(λ) = [ Qy(λ) Qu(λ) ] is the partitioned transfer function matrix of the fault detection filter sysQ  in accordance with the partitioned filter inputs as outputs and controls, then  the transfer function matrix R(λ) of the resulting internal form sysR is given by\n\n R(λ) = | Qy(λ)  Qu(λ) | * | Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) |\n                           |  I       0     0     0     0   |\n\nA minimal descriptor realization is computed if minimal = true and a possibly non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Ar-λEr,Br,Cr,Dr) is the full order descriptor realization of sysR.sys, then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ar, Br, Cr, Dr, the absolute tolerance for the nonzero elements of Er,   and the relative tolerance for the nonzero elements of Ar, Br, Cr, Dr and Er. The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sysR.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfminus","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfminus","text":" fdhinfminus(sys,freq) -> (β, ind, fr)\n\nCompute for a stable descriptor system sys = (A-λE,B,C,D) the H∞- index β of its transfer function matrix G(λ). If freq = missing (default), then β is the  minimum H∞-norm of the columns of G, ind is the index of the minimum-norm column and fr is  the frequency where the minimum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then β is the minimum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the minimum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfmax","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfmax","text":" fdhinfmax(sys,freq) -> (γ, ind, fr)\n\nCompute for a descriptor system sys = (A-λE,B,C,D), γ - the maximum norm of the columns of its transfer function matrix G(λ). If freq = missing (default), then γ is the  maximum H∞-norm of the columns of G, ind is the index of the maximum-norm column and fr is  the frequency where the maximum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then γ is the maximum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the maximum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#Solving-fault-detection-and-isolation-problems","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"","category":"section"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn  Exact synthesis of fault detection filters.","category":"page"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn","category":"page"},{"location":"FDIsynthesis.html#FaultDetectionTools.efdsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.efdsyn","text":"efdsyn(sysf::FDIModel; rdim, nullspace = true, simple = false, minimal = true, \n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection problem (EFDP) for a given synthesis model sysf with additive faults. The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EFDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.S, and info.HDesign,  contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu*u + Gd*d + Gf*f + Gw*w + Ga*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu, Gd, Gf, Gw, and Ga the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy*y + Qu*u\n\nand the indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter in internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru*u + Rd*d + Rf*f + Rw*w + Ra*aux ,\n\nwhere \n\n   | Ru Rd Rf Rw Ra | = |Qy Qu]*| Gu Gd Gf Gw Ga |. \n                                | I  0  0  0  0  |\n\nThe solution of the EFDP ensures that Ru = 0, Rd = 0, and Rf has all its columns nonzero.  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe resulting filters Q.sys and R.sys have observable state-space realizations (AQ,BQ,CQ,DQ) and (AQ,BR,CQ,DR), respectively, and thus share the observable pairs (AQ,CQ). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false a full order synthesis is performed.  \n\nIf HDesign = H, a full row rank design matrix H is used to build rdim = q  linear combinations of the left nullspace basis vectors (default: HDesign = missing)\n\nrdim = q specifies the desired number q of residual outputs for Q and R.  The default value of q is chosen as follows: if HDesign = missing, then   q = 1, if minimal = true, or q is the number of the nullspace basis  vectors used for the initial synthesis, if minimal = false;  if HDesign = H specifies a full row rank design matrix H,  then q is the row dimension of H. \n\nFDFreq = freq specifies a vector of real frequency values or a scalar real frquency value for strong detectability checks (default: FDFreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used for the synthesis of the fault detection filter. If nullspace = false, a full-order observer based nullspace basis is used.  This option can be only used for a proper system without disturbance inputs. \n\nIf simple = true, a simple proper nullspace basis is emplyed for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then no simple basis is computed. \n\nTo assess the stability of poles, a boundary offset  β can be specified via the keyword argument offset = β.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe stability domain Cs of poles is defined by  the keyword argument for the stability margin smarg = α, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nThe poles of the filters Q and R can be specified using the keyword arguments poles and sdeg, where poles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs (default: poles = missing) and sdeg = γ is the prescribed stability degree for the poles (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\nThe maximum alowed condition number tcmax of the employed non-orthogonal transformations  can be specified as tcond = tcmax (Default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, S, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= cmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G := [ Gu Gd; I 0] (also the left Kronecker indices of G), if the  state-space realization of [Gu Gd] is minimal;\n\ninfo.S is the binary structure matrix corresponding to the computed left nullspace basis;\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter.\n\nMethod: The Procedure EFD from [1] is implemented to solve  the exact fault detection problem. For more details on  the least order synthesis of fault detection filters see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.2.\n\n[2] A. Varga, On computing least order fault detectors using rational nullspace bases.  IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = FaultDetectionTools\nDocTestSetup = quote\n    using FaultDetectionTools\nend","category":"page"},{"location":"index.html#FaultDetectionTools.jl","page":"Home","title":"FaultDetectionTools.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The FaultDetectionTools.jl package (or shortlyFDITools) is a collection of Julia functions for the analysis and solution  of fault detection problems. The functions of this collection relies on  the DescriptorSystems package [2], whose underlying computational functions are based on the MatrixPencils.jl [3] and MatrixEquations.jl [4] packages. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The implemented functions are based on the computational procedures described in Chapters 5, 6 and 7 of the book:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga, \"Solving Fault Diagnosis Problems, Linear Synthesis Techniques\", vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, xxviii+394, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This book describes the mathematical background of solving synthesis problems of fault detection and model detection filters and gives detailed descriptions of the underlying synthesis procedures. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The targetted functionality parallels the functionality of the MATLAB collection of tools FDITOOLS, whose User's Guide of the version V1.0 is provided in the file fditoolsdoc.pdf.   Supplementary information on the targetted functionality is also available on arXiv in the documentation of the companion MATLAB FDITOOLS collection.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The available functions in the current version of the FaultDetectionTools.jl package are:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Building fault detection and isolation related objects","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FDIModel  Falt detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDFilterIF  Fault detection filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Performance evaluation of FDI filters","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdscond  Computation of the fault detection sensitivity condition.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solving fault detection and isolation problems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"efdsyn  Exact synthesis of fault detection filters.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FDI related utilities","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fdIFeval  Evaluation of the internal form of a fault detection filter. \nfdhinfminus  Evaluation of the H∞- index.  \nfdhinfmax  Evaluation of the maximum of column norm.  ","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/FaultDetectionTools.jl/blob/main/ReleaseNotes.md)","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[2]  A. Varga, DescriptorSystems.jl: Manipulation of generalized state-space (descriptor) system representations. Zenodo: https://doi.org/10.5281/zenodo.5148319.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[4]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"},{"location":"makeindex.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html","page":"Index","title":"Index","text":"Pages = [ \"FDIObjects.md\",\n          \"FDIperformance.md\",\n          \"FDIsynthesis.md\",\n          \"FDIutils.md\" ]\nModule = [\"FaultDetectionTools\"]\nOrder = [:type, :function]","category":"page"}]
}
