var documenterSearchIndex = {"docs":
[{"location":"FDIObjects.html#Building-fault-detection-and-isolation-related-objects","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"","category":"section"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel  Fault detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDIFilter  Fault detection and isolation filter object.\nFDFilterIF  Fault detection filter internal form object.\nFDIFilterIF  Fault detection and isolation filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.\nfdIFeval  Evaluation of the internal forms of fault detection and isolation filters. ","category":"page"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel\nfdimodset\nFDFilter\nFDFilter(::DescriptorSystems.DescriptorStateSpace, ::Int, ::Int)\nFDFilterIF\nFDFilterIF(::DescriptorSystems.DescriptorStateSpace, ::Int, ::Int, ::Int)\nFDIFilter\nFDIFilter(::Array{DescriptorSystems.DescriptorStateSpace{T},1}, ::Int, ::Int) where T\nFDIFilterIF\nFDIFilterIF(::Array{DescriptorSystems.DescriptorStateSpace{T},1}, ::Int, ::Int, ::Int) where T\nfdIFeval","category":"page"},{"location":"FDIObjects.html#FaultDetectionTools.FDIModel","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIModel","text":"FDIModel <: AbstractFDDObject\n\nType for synthesis models employed to solve fault detection and isolation problems.\n\nIf sysf::FDIModel is the synthesis model object, the underlying descriptor system model can be obtained via sysf.sys and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in sysf.controls, sysf.disturbances, sysf.faults,  sysf.noise and sysf.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.fdimodset","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.fdimodset","text":"fdimodset(sys; controls, c, disturbances, d, faults, f, fa, faults_sen, fs, noise, n, aux) -> sysf::FDIModel\n\nBuild for a given linear time-invariant system model sys = (A-λE,B,C,D), a synthesis model object sysf  to be used in conjunction with the analysis and synthesis functions of FDI filters.  The information on the partition of the input components in control, disturbance, fault, noise and auxiliary inputs can be specified using the following keyword arguments:\n\ncontrols = inpu or c = inpu specifies the indices inpu of the control inputs (default: void)\n\ndisturbances = inpd or d = inpd specifies the indices inpd of the disturbance inputs (default: void)\n\nfaults = inpf or f  = inpf specifies the indices inpf of the fault inputs (default: void)\n\nfa = inpfa specifies the indices inpfa of control inputs subject to actuator fault (default: void)\n\nfaults_sen = inpfs or fs = inpfs specifies the indices inpfs of the system outputs subject to sensor fault inputs (default: void)\n\nnoise = inpn or  noise = inpn specifies the indices inpn of the noise inputs (default: void)\n\naux = inpa specifies the indices inpa of the auxiliary inputs (default: void)\n\nThe indices of inputs or outputs can be specified as integer vectors, integer scalars or integer UnitRanges.\n\nThe resulting sysf contains the partitioned system  sysf.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]), where  Bu, Bd, Bf, Bw and Bv are the input matrices from the control inputs u, disturbance inputs d, fault inputs f,  noise inputs w and auxiliary inputs v, respectively, and Du, Dd, Df, Dw and Dv are the feedthrough matrices from those inputs. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nMethod: If G(λ) is the p x m transfer function matrix of sys, then the resulting system sysf has an  equivalent input output form [Gu(λ) Gd(λ) Gf(λ) Gw(λ) Gv(λ)], where the following relations define the component matrices: Gu(λ) = G(λ)*Su, Gd(λ) = G(λ)*Sd,  Gf(λ) = [G(λ)*Sf Ss], Gw(λ) = G(λ)*Sw,  Gv(λ) = G(λ)*Sv, with the selection matrices Su, Sd, Sf, Sw and Sv formed from the columns of the m-th order identity matrix and  Ss is formed  from the columns of the p-th order identity matrix. \n\n\n\n\n\n","category":"function"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter <: AbstractFDDObject\n\nType for fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilter is the fault detection filter object, the underlying descriptor system model can be obtained via filter.sys and the indices of output and control inputs  can be accessed as the integer vectors  contained in filter.outputs and filter.controls, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter-Tuple{DescriptorStateSpace, Int64, Int64}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter(sys, p, mu) -> Q::FDFilter\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter object Q, as determined with the synthesis functions of FDI filters.  p and mu are the number of measured outputs and the number of control inputs, respectively.  It is assumed that B = [By Bu Bv] and D = [Dy Du Dv] are partitioned matrices such that By and Dy have p columns, and Bu and Du have mu columns,  where By and Bu are the input matrices from the measured outputs y and  control inputs u, Dy and Du are the feedthrough matrices from the measured outputs y and  control inputs u. \n\nThe resulting Q contains the partitioned system  Q.sys = (A-λE,[By Bd],C,[Dy Du]) and the indices of inputs corresponding  to the measured outputs and control inputs are contained in the associated  integer vectors Q.outputs and Q.controls. \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF <: AbstractFDDObject\n\nType for the internal form of fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilterIF is the fault detection filter internal form object,  the underlying descriptor system model can be obtained via filter.sys and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in filter.controls, filter.disturbances, filter.faults,  filter.noise and filter.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF-Tuple{DescriptorStateSpace, Int64, Int64, Int64}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF(sys, mu, md, mf, mw = 0, maux = 0; moff = 0 ) -> R::FDFilterIF\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter internal form object R, as determined with the synthesis functions of FDI filters.  mu, md, mf, mw and maux are the dimensions of control, disturbance, fault, noise and auxiliary input vectors, respectively. It is assumed that B = [Boff Bu Bd Bf Bw Bv] and D = [Doff Du Dd Df Dw Dv] are partitioned matrices such that Boff and Doff have moff columns, Bu and Du have mu columns, Bd and Dd have md columns,  Bf and Df have mf columns,  Bw and Dw have mw columns, and Bv and Dv have maux columns.   \n\nThe resulting R contains the partitioned system  R.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]) and the indices of inputs corresponding  to the control, disturbance, fault, noise and auxiliary inputs are contained in the associated  integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux.  \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilter","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilter","text":"FDIFilter <: Vector{AbstractFDDObject}\n\nType for fault detection and isolation filters resulted as solutions of fault detection and isolation problems.\n\nIf filter::FDIFilter is the fault detection and isolation filter object,  the underlying i-th descriptor system models can be obtained via filter.sys[i] and the indices of output and control inputs  can be accessed as the integer vectors  contained in filter.outputs and filter.controls, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilter-Union{Tuple{T}, Tuple{Array{DescriptorStateSpace{T}, 1}, Int64, Int64}} where T","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilter","text":"FDIFilter(sys, p, mu) -> Q::FDIFilter\n\nBuild for a vector of linear time-invariant descriptor system models sys[i] = (Ai-λEi,Bi,Ci,Di) with the same number of inputs, a fault detection and isolation filter object Q,  as determined with the synthesis functions of FDI filters.  p and mu are the number of measured outputs and the number of control inputs, respectively.  It is assumed that each Bi = [Byi Bui Bvi] and Di = [Dyi Dui Dvi] are partitioned matrices such that Byi and Dyi have p columns, and Bui and Dui have mu columns,  where Byi and Bui are the input matrices from the measured outputs y and  control inputs u, Dyi and Dui are the feedthrough matrices from the measured outputs y and  control inputs u. \n\nThe resulting Q contains the vector of partitioned systems Q.sys[i] = (Ai-λEi,[Byi Bdi],Ci,[Dyi Dui]) and the indices of inputs corresponding  to the measured outputs and control inputs are contained in the associated  integer vectors Q.outputs and Q.controls. \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilterIF","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilterIF","text":"FDIFilterIF <: AbstractFDDObject\n\nType for the internal form of fault detection and isolation filters resulted as solutions of fault detection and isolation problems.\n\nIf filter::FDIFilterIF is the fault detection and isolation filter internal form object,  the underlying i-th descriptor system models can be obtained via filter.sys[i] and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in filter.controls, filter.disturbances, filter.faults,  filter.noise and filter.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilterIF-Union{Tuple{T}, Tuple{Array{DescriptorStateSpace{T}, 1}, Int64, Int64, Int64}} where T","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilterIF","text":"FDIFilterIF(sys, mu, md, mf, mw = 0, maux = 0; moff = 0 ) -> R::FDIFilterIF\n\nBuild for a a vector of linear time-invariant descriptor system models sys[i] = (Ai-λEi,Bi,Ci,Di)  with the same number of inputs, ,  a fault detection and isolation filter internal form object R, as determined with the synthesis functions of FDI filters.  mu, md, mf, mw and maux are the dimensions of control, disturbance, fault, noise and auxiliary input vectors, respectively. It is assumed that each Bi = [Boffi Bui Bdi Bfi Bwi Bvi] and Di = [Doffi Dui Ddi Dfi Dwi Dvi] are partitioned matrices such that Boffi and Doffi have moff columns, Bui and Dui have mu columns, Bdi and Ddi have md columns,  Bfi and Dfi have mf columns,  Bwi and Dwi have mw columns, and Bvi and Dvi have maux columns.   \n\nThe resulting R contains the vector of partitioned systems  R.sys[i] = (A-λE,[Bui Bdi Bfi Bwi Bvi],C,[Dui Ddi Dfi Dwi Dvi]) and the indices of inputs corresponding  to the control, disturbance, fault, noise and auxiliary inputs are contained in the associated  integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux.  \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.fdIFeval","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.fdIFeval","text":"fdIFeval(sysQ::FDFilter, sysf::FDIModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::FDFilterIF\n\nCompute the internal form sysR of the fault detection filter sysQ applied to the synthesis model sysf.  If sysf has the partitioned transfer function matrix G(λ) = [ Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) ] in accordance with the partitioned system inputs as controls, disturbances, faults, noise and auxiliary inputs, respectively, and Q(λ) = [ Qy(λ) Qu(λ) ] is the partitioned transfer function matrix of the fault detection filter sysQ  in accordance with the partitioned filter inputs as outputs and controls, then  the transfer function matrix R(λ) of the resulting internal form sysR is given by\n\n R(λ) = | Qy(λ)  Qu(λ) | * | Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) |\n                           |  I       0     0     0     0   |\n\nA minimal descriptor realization is computed if minimal = true and a possibly non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Ar-λEr,Br,Cr,Dr) is the full order descriptor realization of sysR.sys, then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ar, Br, Cr, Dr, the absolute tolerance for the nonzero elements of Er,   and the relative tolerance for the nonzero elements of Ar, Br, Cr, Dr and Er. The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sysR.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\nfdIFeval(sysQ::FDIFilter, sysf::FDIModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::FDIFilterIF\n\nCompute the internal form sysR of the fault detection and isolation filter sysQ applied to the synthesis model sysf.  If sysf has the partitioned transfer function matrix G(λ) = [ Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) ] in accordance with the partitioned system inputs as controls, disturbances, faults, noise and auxiliary inputs, respectively, and Qi(λ) = [ Qyi(λ) Qui(λ) ] is the partitioned transfer function matrix of the i-th filter sysQ.sys[i]  in accordance with the partitioned filter inputs as outputs and controls, then  the transfer function matrix Ri(λ) of the i-th filter in the resulting internal form sysR.sys[i] is given by\n\n Ri(λ) = | Qyi(λ)  Qui(λ) | * | Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) |\n                              |  I       0     0     0     0   |\n\nMinimal descriptor realizations are computed if minimal = true and a possibly non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Ari-λEri,Bri,Cri,Dri) is the full order descriptor realization of sysR.sys[i], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ari, Bri, Cri, Dri, the absolute tolerance for the nonzero elements of Eri,   and the relative tolerance for the nonzero elements of Ari, Bri, Cri, Dri and Eir. The default relative tolerance is ni*ϵ, where ϵ is the working machine epsilon  and ni is the order of the system sysR.sys[i].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"FDIanalysis.html#Analysis-of-FDI-synthesis-models","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"","category":"section"},{"location":"FDIanalysis.html","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"fdigenspec  Generation of achievable FDI specifications.\nfdichkspec  Feasibility analysis of a set of FDI specifications.","category":"page"},{"location":"FDIanalysis.html","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"fdigenspec\nfdichkspec","category":"page"},{"location":"FDIanalysis.html#FaultDetectionTools.fdigenspec","page":"Analysis of FDI synthesis models","title":"FaultDetectionTools.fdigenspec","text":"S = fdigenspec(sysf::FDIModel; sdeg, FDtol, FDGainTol, FDfreq, atol, atol1, atol2, atol3, rtol, fast = true)\n\nGenerate all achievable specifications S for a given synthesis model sysf with additive faults.  Each row of the resulting binary matrix S contains a nonzero specification (or fault signature) which can be achieved using a linear fault detection filter (e.g., as obtainable with the help of function efdisyn).\n\nFDFreq = freq specifies a vector of real frequency values or a scalar real frquency value for strong detectability checks (default: FDFreq = missing).\n\nFDtol = tol1 specifies the threshold tol1 for assessing weak specifications                       (see also function fditspec) (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for assessing strong specifications,   i.e., the threshold for nonzero frequency responce gains for all frequency values specified in freq (see also function fdisspec) (default: tol2 = 0.01). \n\nThe keyword argument sdeg = β specifies a prescribed stability degree β for the poles of the internally  generated candidate filters, such that the real parts of filters poles must be less than or equal to β, in the continuous-time case, and  the magnitudes of filter poles must be less than or equal to β, in the discrete-time case. If sdeg = missing then no then no stabilization is performed if and FDFreq = missing. If sdeg = missing and FDFreq = freq, then the fllowing default values are employed : β = -0.05, in continuous-time case, and  β = 0.95,  in discrete-time case. \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nMethod: The Procedure GENSPEC from [1] is implemented.  The nullspace method [2] is recursively employed to generate candidate fault detection and isolation filters, whose internal forms provide the structure matrices corresponding to the achievable weak specifications, if freq = missing,  or strong specifications for the frequencies conatined in freq. The generation method is also described in [3].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.       Springer Verlag, 2017; sec. 5.4.\n\n[2] A. Varga, On computing nullspace bases – a fault detection perspective.        Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n[3] A. Varga, On computing achievable fault signatures. Proc. SAFEPROCESS'2009, Barcelona, Spain. \n\n\n\n\n\n","category":"function"},{"location":"FDIanalysis.html#FaultDetectionTools.fdichkspec","page":"Analysis of FDI synthesis models","title":"FaultDetectionTools.fdichkspec","text":"fdichkspec(sysf::FDIModel, SFDI::BitMatrix; sdeg, FDtol, FDGainTol, FDfreq, \n             atol, atol1, atol2, atol3, rtol, fast = true, minimal = false) -> (rdims, orders, leastorders)\n\nCheck for a given synthesis model sysf::FDIModel the feasibility of a set of fault detection and isolation specifications SFDI.  If SFDI has N rows (i.e., contains N specifications), then the N-dimensional integer vectors rdims, orders, leastorders  are returned and contain information related to the synthesis of FDI filters to achieve the feasible specifications.  For the i-th specification contained in SFDI[i,:], rdims[i] contains the number of residual  outputs of a minimal nullspace basis based FDI filter which can be used to achieve this specification.  If rdims[i] = 0, then the i-th specification is not feasible. For a feasible i-th specification, orders[i]  contains the order of the minimal nullspace basis based FDI filter which can be used to achieve this specification.  If the i-th specification is not feasible, then orders[i] is set to -1. If minimal = true, leastorders[i] contains the least achievable order for a scalar output FDI filter which can be used   to achieve the i-th specification. If minimal = false or if the i-th specification is not  feasible, then leastorders[i] is set to -1.\n\nFDFreq = freq specifies a vector of real frequency values or a scalar real frquency value for strong detectability checks (default: FDFreq = missing).\n\nFDtol = tol1 specifies the threshold tol1 for assessing weak specifications                       (see also function fditspec) (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for assessing strong specifications,   i.e., the threshold for nonzero frequency responce gains for all frequency values specified in freq (see also function fdisspec) (default: tol2 = 0.01). \n\nThe keyword argument sdeg = β specifies a prescribed stability degree β for the poles of the internally  generated candidate filters, such that the real parts of filters poles must be less than or equal to β, in the continuous-time case, and  the magnitudes of filter poles must be less than or equal to β, in the discrete-time case. If sdeg = missing then no then no stabilization is performed if and FDFreq = missing. If sdeg = missing and FDFreq = freq, then the fllowing default values are employed : β = -0.05, in continuous-time case, and  β = 0.95,  in discrete-time case. \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nMethod: The nullspace method of [1] is successively employed to  determine FDI filters as minimal left nullspace bases which solve  suitably formulated fault detection problems. \n\nReferences:\n\n[1] A. Varga, On computing nullspace bases – a fault detection perspective.        Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#Performance-evaluation-of-FDI-filters","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"","category":"section"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdiscond  Computation of the fault detection sensitivity condition.\nfdif2ngap  Computation of the fault-to-noise gap.\nfdimmperf  Computation of the model-matching performace.","category":"page"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec\nfdisspec\nfdiscond\nfdif2ngap\nfdimmperf","category":"page"},{"location":"FDIperformance.html#FaultDetectionTools.fditspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fditspec","text":"S = fditspec(sysr::FDFilterIF; FDfreq = missing, block = false, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the transfer function matrix Rf(λ) of  the transfer channel from the fault inputs to residuals of  a fault detection filter internal form object sysr::FDFilterIF.   For a filter sysr with q residual outputs and mf fault inputs,  Rf(λ) is the q x mf transfer function matrix of the fault inputs channel with the descriptor system representation sysr.sys[:,sysr.faults] := (Af-lambda*Ef,Bf,Cf,Df). \n\nIf FDfreq = missing (default), then S contains the weak structure matrix of Rf(λ).  For block = false, S is determined as a q x mf  binary matrix (BitMatrix), whose (i,j)-th element is S[i,j] = 1, if the (i,j)-th element of Rf(λ) is  nonzero, and otherwise, S[i,j] = 0.  For block = true, S is determined as a 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of Rf(λ) is nonzero, and otherwise, S[1,j] = 0. \n\nIf FDfreq = freq specifies a vector freq of nf real frequencies  which characterize the classes of persistent fault signals, then  for a suitable proper and invertible M(λ) (see below),   S contains the strong structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts. \n\nFDtol = tol1 specifies an absolute threshold tol1 for the magnitudes of nonzero elements in the system matrices  Bf and Df and is used to determine the weak structure matrix.  Its default value is tol1 = 0.0001*max(1, norm(Bf,1), norm(Df,1)). \n\nFDStol = tol2 specifies an absolute  threshold tol2 for the magnitudes of nonzero elements in the system matrices  Af, Ef, Bf, Cf and Df and is used to determine the strong structure matrix.  Its default value is  tol2 = epsm*max(1, norm(Ef,1), norm(Af,1), norm(Bf,1), norm(Cf,Inf), norm(Df,1))),  where epsm is the working machine precision.\n\nFor block = false, then, if poleshift = true, M(λ) is chosen diagonal such that M(λ)*Rf(λ) has no poles in Ω and if poleshift = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as a q x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the (i,j)-th element of M(λ)*Rf(λ)  evaluated for all frequencies in Ω is nonzero, and otherwise, S[i,j] = 0.  \n\nFor block = true, then, if poleshift = true, M(λ) is chosen such that M(λ)*Rf(λ)  as no poles in Ω and if poleshift = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as an 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of M(λ)*Rf(λ) evaluated for all frequencies in Ω is nonzero and otherwise S[1,j] = 0. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nMethod: For the definition of the structure matrix, see [1]. For the determination of the weak structure matrix, minimal realizations are determined for each column of Rf(λ) if block = true or for  each element of Rf(λ) if block = false and the nonzero columns or  elements in each column are identified  (see Corollary 7.1 of [1]). For the determination of the strong structure matrix, minimal realizations are determined for each column of M(λ)*Rf(λ) if block = true or for  each element of M(λ)*Rf(λ) if block = false and  the full rank of the corresponding system matrix is checked for all frequencies in FDfreq (see Corollary 7.2 in [1]) (i.e., the lack of zeros in all frequencies).\n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec.3.4.\n\n\n\n\n\nS = fditspec(sysr::FDIFilterIF; FDfreq = missing, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the global transfer function matrix Rf(λ) of  the transfer channel from the fault inputs to residuals of  a fault detection and isolation filter internal form object sysr::FDIFilterIF.   The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where the fault to residual channel of the i-th filter sysr.sys[i][:,sysr.faults]  has qi residual outputs and mf fault inputs, has the descriptor system representation sysr.sys[i][:,sysr.faults] := (Afi-lambda*Efi,Bfi,Cfi,Dfi) and  Rfi(λ) is the corresponding qi x mf transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)].  For the evaluation of the strong structure matrix, the structure matrix of the stable  transfer function matrix M(λ)*Rf(λ) is determined, with a M(λ) block-diagonal M(λ) = block-diag(M1(λ), M2(λ), ..., MN(λ)), where Mi(λ) is a suitable square and invertible  transfer function matrix (see below). \n\nFDtol = tol1 specifies an absolute threshold tol1 for the magnitudes of nonzero elements in the system matrices  Bf and Df and is used to determine the weak structure matrix.  Its default value is tol1 = 0.0001*max(1, norm(Bf,1), norm(Df,1)). \n\nFDStol = tol2 specifies an absolute  threshold tol2 for the magnitudes of nonzero elements in the system matrices  Af, Ef, Bf, Cf and Df and is used to determine the strong structure matrix.  Its default value is  tol2 = epsm*max(1, norm(Ef,1), norm(Af,1), norm(Bf,1), norm(Cf,Inf), norm(Df,1))),  where epsm is the working machine precision.\n\nIf FDfreq = missing (default), then S contains the weak structure matrix of Rf(λ).  S is determined as a N x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the j-th column of Rfi(λ) is nonzero, and otherwise, S[i,j] = 0. \n\nIf FDfreq = freq specifies a vector freq of nf real frequencies  which characterize the classes of persistent fault signals, then  for a suitable proper and invertible M(λ) (see below),   S contains the strong structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts. \n\nS is determined as a N x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the j-th column of Mi(λ)*Rfi(λ) is nonzero for all frequencies in Ω, and otherwise, S[i,j] = 0.  If poleshift = true, Mi(λ) is chosen such that Mi(λ)*Rfi(λ) has no poles in Ω and if poleshift = false (default), Mi(λ) = I is used and an error is issued if any Rfi(λ) has poles in Ω. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nMethod: For the definition of the structure matrix, see [1]. For the determination of the weak structure matrix, minimal realizations are determined for each column of Rfi(λ) and the nonzero columns are identified  (see Corollary 7.1 of [1]). For the determination of the strong structure matrix, minimal realizations are determined for each column of Mi(λ)*Rfi(λ) and  the full rank of the corresponding system matrix is checked for all frequencies in Ω (see Corollary 7.2 in [1]) (i.e., the lack of zeros in all frequencies in Ω).\n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec.3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdisspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdisspec","text":" S = fdisspec(sysr::FDFilterIF, freq; block = false, stabilize = false, FDGainTol = 0.01, \n                 atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute, for a given set of real frequencies freq,   the strong binary structure matrix S of the stable transfer function matrix M(λ)*Rf(λ),  where Rf(λ) is the transfer function matrix of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF and   M(λ) is a suitable proper and invertible stabilizing transfer function matrix (see below).   For a filter sysr with q residual outputs and mf fault inputs,  Rf(λ) is the q x mf transfer function matrix of the fault inputs channel with the descriptor system representation sysr.sys[:,sysr.faults] := (Af-lambda*Ef,Bf,Cf,Df). \n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent fault signals  (default: freq = 0, i.e., characterizing constant faults). S contains the strong  structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts.  \n\nFDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nFor block = false, then, if stabilize = true, M(λ) is chosen diagonal such that M(λ)*Rf(λ) has only stable poles and if stabilize = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as a q x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the (i,j)-th element of M(λ)*Rf(λ)  evaluated for all frequencies in freq is larger than or equal to tol, and otherwise, S[i,j] = 0.  \n\nFor block = true, then, if stabilize = true, M(λ) is chosen such that M(λ)*Rf(λ)  has only stable poles and if stabilize = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as an 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of M(λ)*Rf(λ) evaluated for all frequencies in Ω is larger than or equal to tol and otherwise, S[1,j] = 0. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,  the absolute tolerance for the nonzero elements of Cf,    and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nMethod: S is evaluated using the definition of the strong structure matrix in [1]. \n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec. 3.4.\n\n\n\n\n\n S = fdisspec(sysr::FDIFilterIF, freq; stabilize = false, FDGainTol = 0.01, \n                 atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute, for a given set of real frequencies freq,   the strong binary structure matrix S  of the stable transfer function matrix M(λ)*Rf(λ), where Rf(λ) is the global  transfer function matrix of the transfer channel from the fault inputs to residuals of the fault detection and isolation filter internal form object sysr::FDIFilterIF and   M(λ) is a suitable block-diagonal proper and invertible stabilizing transfer function matrix (see below).   The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where the fault to residual channel of the i-th filter sysr.sys[i][:,sysr.faults]  has qi residual outputs and mf fault inputs, has the descriptor system representation sysr.sys[i][:,sysr.faults] := (Afi-lambda*Efi,Bfi,Cfi,Dfi) and  Rfi(λ) is the corresponding qi x mf transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)].  M(λ) = block-diag(M1(λ), M2(λ), ..., MN(λ)), where Mi(λ) is square and invertible  and chosen such that Mi(λ)Rfi(λ) is stable (see below). \n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent fault signals  (default: freq = 0, i.e., characterizing constant faults). S contains the strong  structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts.  \n\nFDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nIf stabilize = true, Mi(λ) is chosen such that Mi(λ)*Rfi(λ) has only stable poles and if stabilize = false (default), Mi(λ) = I is used and an error is issued  if any Rfi(λ) has poles in Ω. \n\nS is determined as a N x mf  binary matrix, whose (i,j)-th element is S[i,j] = 1, if the norm of the  j-th column of Mi(λ)*Rfi(λ) evaluated for all frequencies in Ω  is larger than or equal to tol, and otherwise, S[i,j] = 0. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Afi, Bfi, Cfi, Dfi, the absolute tolerance for the nonzero elements of Efi,  the absolute tolerance for the nonzero elements of Cfi,    and the relative tolerance for the nonzero elements of Afi, Bfi, Cfi, Dfi and Efi.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nMethod: S is evaluated using the definition of the strong structure matrix in [1]. \n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec. 3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdiscond","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdiscond","text":" fdiscond(sysr::FDFilterIF,freq) -> (scond, β, γ)\n\nCompute for the stable transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF the quantities:  β - the H∞- index of Rf(λ), γ - the maximum of the columns norms of Rf(λ) and  the fault detection sensitivity condition scond evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n fdiscond(sysr::FDIFilterIF, SFDI, freq) -> (scond, β, γ)\n\nCompute the detection and isolation sensitivity condition scond (and related quatities β and γ) for the N × mf binary structure matrix SFDI associated to the stable global transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter and  Rfi(λ) is the corresponding transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)]. It is assumed that for each j such that SFDI[i,j] = 1, the j-th column of Rfi(λ) is nonzero  and  for each j such that SFDI[i,j] = 0, the j-th column of Rfi(λ) is zero.  The i-th element of the vectors scond, β and γ contain the quantities:  β[i] - the H∞- index of the nonzero columns of Rfi(λ), γ - the maximum of the nonzero columns norms of Rf(λ) and  the fault detection sensitivity condition scond evaluated as scond[i] := β[i]/γ[i].  If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq. \n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdif2ngap","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdif2ngap","text":" fdif2ngap(sysr::FDFilterIF, freq) -> (gap, β, γ)\n\nCompute the fault-to-noise gap gap (and the related quantities β and γ)  for the stable fault detection filter internal form object sysr::FDFilterIF. For the fault to residual channel of the filter sysr.sys[:,sysr.faults]    with the corresponding transfer function matrix Rf(λ) and  the noise to residual channel of the filter sysr.sys[:,sysr.noise]    with the corresponding transfer function matrix Rw(λ),     β is the H∞- index of Rf(λ), γ is the H∞-norm of Rw(λ) and  gap is the fault-to-noise gap evaluated as gap := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq.  gap = ∞ if there are no noise inputs and gap = 0 if there are no fault inputs.\n\n\n\n\n\n fdif2ngap(sysr::FDFilterIF, SFDI, freq) -> (gap, β, γ)\n\nCompute the fault-to-noise gap gap (and the related quantities β and γ)  for the stable fault detection filter internal form object sysr::FDFilterIF and the associated structure vector SFDI. sysr.sys[:,sysr.faults] is the fault to residual channel of the filter  with the corresponding transfer function matrix Rf(λ) and  sysr.sys[:,sysr.noise] is the noise to residual channel of the filter  with the corresponding transfer function matrix Rw(λ).    If  Rff(λ) is the transfer function matrix formed of those j-th columns of Rf(λ)  for which SFDI[j] = true and Rdf(λ) is the transfer function matrix formed of  those j-th columns of Rf(λ) for which SFDI[j] = false, then:    β is the H∞- index of Rff(λ), γ is the H∞-norm of [Rdf(λ) Rw(λ)] and  gap is the fault-to-noise gap evaluated as gap := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq.  gap = ∞ if [Rdf(λ) Rw(λ)] = 0 and gap = 0 if Rff(λ) = 0.\n\n\n\n\n\n fdif2ngap(sysr::FDIFilterIF, SFDI, freq; atol = √ϵ) -> (gap, β, γ)\n\nCompute the fault-to-noise gap  gap (and the related quatities β and γ) for the N × mf binary structure matrix SFDI associated to the stable global transfer function matrices Rf(λ) and Rw(λ) of the transfer channels from the fault inputs to residuals and noise inputs to residuals, respectively,  of the fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter  with the corresponding transfer function matrix Rfi(λ) and sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ).    The global transfer function matrices Rf(λ) areand Rw(λ) formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)] and  Rw(λ) := [ Rw1(λ); Rw2(λ); ...; RwN(λ)]  Let  Rffi(λ) be the transfer function matrix formed of those j-th columns of Rfi(λ)  for which SFDI[i,j] = 1 and let Rdfi(λ) be the transfer function matrix formed of those j-th columns of Rfi(λ)  for which SFDI[i,j] = 0.  The i-th element of the vectors gap, β and γ contain the quantities:  β[i] - the H∞- index of Rffi(λ), γ[i] - the H∞-norm of [Rdfi(λ) Rwi(λ)] and  the fault-to-noise gap gap evaluated as gap[i] := β[i]/γ[i].  gap[i] = ∞ if [Rdfi(λ) Rwi(λ)] = 0 and gap[i] = 0 if Rffi(λ) = 0. If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq.  atol is an absolute tolerance for the norms Rwi(λ), such that norm values less than or equal to atol are  considered zero (default:  √ϵ, where ϵ is the working machine precision.)\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdimmperf","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdimmperf","text":" γ = fdimmperf(sysr::FDFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF.  If Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[i][:,sysr.noise], then γ is the  H∞-norm of Rw(λ), if nrmflag = Inf (default) and the  H2-norm of Rw(λ), if nrmflag = 2. The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix Rw(λ) of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF for a given binary structure vector SFDI. If Rf(λ) is the transfer function matrix of the  transfer channel from the fault inputs to residuals sysr.sys[i][:,sysr.faults] and  Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[i][:,sysr.noise], then γ is the  H∞-norm of [Rdf(λ) Rw(λ)], if nrmflag = Inf (default) and the  H2-norm of [Rdf(λ) Rw(λ)],  if nrmflag = 2, where Rdf(λ) is the transfer function matrix formed by those j-th columns of Rf(λ) for which  SFDI[j] = 0.   The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rdf(λ) Rw(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the stable fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ). Then,  γ is an N-dimensional vector whose i-th component is the  H∞-norm of Rwi(λ), if nrmflag = Inf (default)  and the  H2-norm of Rwi(λ), if nrmflag = 2. The i-th component of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix Rwi(λ) of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the stable fault detection and isolation  filter internal form object sysr::FDIFilterIF and the associated binary structure matrix SFDI.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter  with the corresponding transfer function matrix Rfi(λ) and sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ). Then,  γ is an N-dimensional vector whose i-th component is the  H∞-norm of [Rfdi(λ) Rwi(λ)], if nrmflag = Inf (default)  or the  H2-norm of [Rfdi(λ) Rwi(λ)], if nrmflag = 2, where Rfdi(λ) is the transfer function matrix whose j-th column is  zero if SFDI[i,j] = 1 and is equal to the j-th column of Rfi(λ) if SFDI[i,j] = 0.  The i-th component of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rfdi(λ) Rwi(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FDI-related-utilities","page":"FDI related utilities","title":"FDI related utilities","text":"","category":"section"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdhinfminus  Evaluation of the H∞- index of the transfer function matrix of a descriptor system model.  \nfdhinfmax  Evaluation of the maximum of column norm of the transfer function matrix of a descriptor system model.  \nfditspec_  Computation of the weak or strong structure matrix of a descriptor system model.\nfdisspec_  Computation of the strong structure matrix of a descriptor system model.\nfdiscond_  Computation of the column-gains sensitivity condition of the transfer function matrix of a descriptor system model.","category":"page"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdhinfminus\nfdhinfmax\nfditspec_\nfdisspec_\nfdiscond_","category":"page"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfminus","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfminus","text":" fdhinfminus(sys,freq) -> (β, ind, fr)\n\nCompute for a stable descriptor system sys = (A-λE,B,C,D) the H∞- index β of its transfer function matrix G(λ). If freq = missing (default), then β is the  minimum H∞-norm of the columns of G, ind is the index of the minimum-norm column and fr is  the frequency where the minimum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then β is the minimum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the minimum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfmax","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfmax","text":" fdhinfmax(sys,freq) -> (γ, ind, fr)\n\nCompute for a descriptor system sys = (A-λE,B,C,D), γ - the maximum norm of the columns of its transfer function matrix G(λ). If freq = missing (default), then γ is the  maximum H∞-norm of the columns of G, ind is the index of the maximum-norm column and fr is  the frequency where the maximum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then γ is the maximum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the maximum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fditspec_","page":"FDI related utilities","title":"FaultDetectionTools.fditspec_","text":"S = fditspec_(sysrf::DescriptorStateSpace; FDfreq = missing, block = false, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the transfer function matrix of a  linear time-invariant system sysrf  (typically representing the transfer channel from the fault inputs to residuals). sysrf has a descriptor system realization of the form sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ).  For the description of keyword parameters see the documentation of fditspec. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdisspec_","page":"FDI related utilities","title":"FaultDetectionTools.fdisspec_","text":" fdisspec_(sysrf::DescriptorStateSpace, freq; block = false, stabilize = false, FDGainTol = 0.01, \n                 atol, atol1, atol2, atol3, rtol, fast = true) -> (S, gains)\n\nCompute the strong binary structure matrix S of the transfer function matrix of a  linear time-invariant system sysrf  (typically representing the transfer channel from the fault inputs to residuals). sysrf has a descriptor system realization of the form sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ).  For the description of keyword parameters see the documentation of fdisspec. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdiscond_","page":"FDI related utilities","title":"FaultDetectionTools.fdiscond_","text":" fdiscond_(sysrf::DescriptorStateSpace, freq) -> (scond, β, γ)\n\nCompute for a stable descriptor system sysrf = (A-λE,B,C,D) with the transfer function matrix Rf(λ),  β - the H∞- index of Rf(λ), γ - the maximum of the columns norms of Rf(λ) and  scond - the column-gains sensitivity condition evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#Solving-fault-detection-and-isolation-problems","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"","category":"section"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn  Exact synthesis of fault detection filters.\nefdisyn  Exact synthesis of fault detection and isolation filters.\nafdsyn  Approximate synthesis of fault detection filters.\nafdisyn  Approximate synthesis of fault detection and isolation filters.","category":"page"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn\nefdisyn\nafdsyn\nafdisyn","category":"page"},{"location":"FDIsynthesis.html#FaultDetectionTools.efdsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.efdsyn","text":"efdsyn(sysf::FDIModel; rdim, nullspace = true, simple = false, minimal = true, \n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection problem (EFDP) for a given synthesis model sysf with additive faults. The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EFDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.S, and info.HDesign,  contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter in internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the EFDP ensures that Ru(λ) = 0, Rd(λ) = 0, and Rf(λ) has all its columns nonzero.  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe resulting filters Q.sys and R.sys have observable state-space realizations (AQ,BQ,CQ,DQ) and (AQ,BR,CQ,DR), respectively, and thus share the observable pairs (AQ,CQ). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false a full order synthesis is performed.  \n\nIf HDesign = H, a full row rank design matrix H is used to build rdim = q  linear combinations of the left nullspace basis vectors (default: HDesign = missing)\n\nrdim = q specifies the desired number q of residual outputs for Q and R.  The default value of q is chosen as follows: if HDesign = missing, then   q = 1, if minimal = true, or q is the number of the nullspace basis  vectors used for the initial synthesis, if minimal = false;  if HDesign = H specifies a full row rank design matrix H,  then q is the row dimension of H. \n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used for the synthesis of the fault detection filter. If nullspace = false, a full-order observer based nullspace basis is used.  This option can be only used for a proper system without disturbance inputs. \n\nIf simple = true, a simple proper nullspace basis is emplyed for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then no simple basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, S, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.S is the binary structure matrix corresponding to the computed left nullspace basis;\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter.\n\nMethod: The Procedure EFD from [1] is implemented to solve  the exact fault detection problem. For more details on  the least order synthesis of fault detection filters see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.2.\n\n[2] A. Varga, On computing least order fault detectors using rational nullspace bases.  IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n\n\n\n\nefdsyn(sysf::FDIModel, S; rdim, nullspace = true, simple = false, minimal = true, \n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection isolation problem (EFDIP) for a given synthesis model sysf with additive faults and a given binary structure vector S.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EFDIP, and its internal form, respectively, and are determined such that R.sys[:,faults] has its j-th column nonzero if S[j] = 1 and the j-th column is zero if S[j] = 0.  For the description of the keyword parameters see the function efdsyn. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.efdisyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.efdisyn","text":"efdisyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, separate = false,\n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection and isolation problem (EFDIP) for a given synthesis model sysf with additive faults and a given binary structure matrix SFDI with nb rows (specifications).  The computed stable and proper filter objects Q and R contain the  fault detection and isolation filter, representing the solution of the EFDIP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs and info.HDesign,  contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection and isolation filter object Q, contains in Q.sys the resulting bank of nb filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i, the i-th component (scalar or vector)  of the overall residual vector r := [r_1; r_2; ...; r_nb].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u   ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the i-th residual component.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter in internal form object R, contains R.sys, the resulting bank of nb  internal form of the filters.   The i-th filter R.sys[i] is in a standard state-space form, which generates the residual signal r_i, and corresponds to the  input-output form\n\n   r_i = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | := |Qyi(λ) Qui(λ)]*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                             |   I     0     0     0     0   |\n\nThe solution of the EFDIP ensures that for the i-th filter, Rui(λ) = 0, Rdi(λ) = 0, and  Rfi(λ) has its j-th column nonzero if the (i,j)-th element of SFDI is nonzero.  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe resulting component filters Q.sys[i] and R.sys[i] have observable state-space realizations (AQi,BQi,CQi,DQi) and (AQi,BRi,CQi,DRi), respectively, and thus share the observable pairs (AQi,CQi). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter synthesis is performed to determine each of the component filters Q.sys[i] and R.sys[i] for i = 1, ...,nb, while  with minimal = false full order synthesis is performed.  \n\nIf HDesign = H, then H is an nb-dimensional array of full row rank or empty design matrices H = [H_1, ..., H_nb], where H_i is the design matrix employed for the synthesis of the i-th component filter (default: HDesign = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filters Q.sys[i] and R.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. The default value of q[i] is chosen as follows: if HDesign = missing or H_i is empty then   q[i] = 1, if minimal = true, or q[i] is the number of the nullspace basis  vectors used for the synthesis of Q.sys[i] and R.sys[i], if minimal = false;  if  H_i specifies a full row rank design matrix, then q[i] is the row dimension of H_i. \n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used at the  initial reduction step, if separate = false,  or at all synthesis steps, if separate = true. If nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step, if separate = false, or at all synthesis steps, if separate = true. This option can  only be used for a proper system without disturbance inputs. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  The orders of the basis vectors employed for the synthesis of i-th filter are provided in info.deg[i].  If simple = false (default), then no simple bases are computed. \n\nIf separate = false (default), a two-step synthesis procedure is employed,  where a minimal proper nullspace basis is used at the  initial reduction step.  If separate = true, the filter components are separately determined by solving appropriately formulated fault detection problems. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, HDesign), where:\n\ninfo.tcond is an nb-dimensional vector, whose i-th component is the maximum of the condition numbers of the employed  non-orthogonal transformation matrices employed for the synthesis of the i-th filter component;  a warning is issued if any info.tcond[i] >= tcmax;\n\ninfo.degs is an nb-dimensional vector, whose i-th component is an integer vector  containing the degrees of the basis vectors of the employed simple nullspace basis for the synthesis of the i-th filter component, if simple = true,  and the degrees of the basis vectors of an equivalent polynomial nullspace basis, ifsimple = false`;\n\ninfo.HDesign is an nb-dimensional vector, whose i-th component is  is the design matrix H_i employed for the synthesis of  the i-th fault detection filter.\n\nMethod: The Procedure EFDI from [1] is implemented to solve  the exact fault detection and isolation problem.  This procedure relies on the nullspace-based synthesis method proposed in [2]. For more  details on the least order synthesis of fault detection filters see [3].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.4.\n\n[2] A. Varga,  On designing least order residual generators for fault detection      and isolation. 16th International Conference on Control Systems and       Computer Science, Bucharest, Romania, 2007.\n\n[3] A. Varga, On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.afdsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.afdsyn","text":"afdsyn(sysf::FDIModel; rdim, nullspace = true, simple = false, minimal = true, exact = false, \n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                          -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection problem (AFDP) for a given synthesis model sysf with additive faults. The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the AFDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.degs2,  info.S, info.S2, info.HDesign, info.HDesign2, info.freq and info.gap contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u  ,\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter in internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the AFDP ensures that Ru(λ) = 0, Rd(λ) = 0, Rf(λ) has all its columns nonzero and the H∞-norm of Rw(λ) satisfies ||Rw(λ)||∞ < γ, where the bound γ is  specified via the keyword argument gamma. The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe transfer function matrices Q(λ) = [ Qy(λ) Qu(λ) ] and R(λ) = [ Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) ]  of the resulting filters Q.sys and R.sys, respectively, have, in general, the partitioned forms\n\n Q(λ) = [ Q1(λ) ] ,   R(λ) = [ R1(λ) ] ,                      (1)\n        [ Q2(λ) ]            [ R2(λ) ]\n\nwhere the filters Q1(λ) and R1(λ) with q1 outputs are the solution of an  AFDP, while the filters Q2(λ) and R2(λ) with q2 outputs are the solution of an   exact fault detection problem formulated for a reduced system obtained   by decoupling the control and disturbance inputs from the residuals (see [4]).   The overall resulting filters Q.sys and R.sys have observable state-space  realizations (AQ,BQ,CQ,DQ) and (AQ,BR,CQ,DR), respectively, and thus   share the observable pairs (AQ,CQ). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false a full order synthesis is performed.  \n\nIf exact = true, an exact synthesis (without optimization) is performed, while  with exact = false (default), an approximate synthesis is performed.  \n\nIf HDesign = H1, a design matrix H1 of full row rank q1 is used to build q1  linear combinations of the left nullspace basis vectors of  G1(λ) := [ Gu(λ) Gd(λ); I 0]. H1 is used in the synthesis of the components  Q1(λ) and R1(λ) in (1) (default: HDesign = missing).\n\nIf HDesign2 = H2, a design matrix H2 of full row rank q2 is used to build q2  linear combinations of the left nullspace basis vectors of  G2(λ) := [ Gu(λ) Gd(λ) Gw(λ); I 0 0]. H2 is used in the synthesis of the components  Q2(λ) and R2(λ) in (1) (default: HDesign2 = missing)\n\nrdim = q specifies the desired number q of residual outputs for Q and R.  If rdim = missing, the default value of q is chosen as q = q1 + q2, where  the default values of q1 and q2 are chosen taking into account the rank rw  of Rw(λ) in the reduced system (see [4]), as follows:  if HDesign = missing, then   q1 = min(1,rw), if minimal = true, or q1 = rw, if minimal = false;  if HDesign = H, then q1 is the row dimension of the design matrix H2. if HDesign2 = missing, then   q2 = 1-min(1,rw), if minimal = true, or q2 = nvec-rw, if minimal = false, where nvec is the number of the nullspace basis  vectors used for the initial synthesis (see [1]);  if HDesign2 = H2, then q2 is the row dimension of the design matrix H2.\n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used for  the initial synthesis of the fault detection filter.  If nullspace = false, a full-order observer based nullspace basis is used.  This option can be only used for a proper system without disturbance inputs. \n\nIf simple = true, a simple proper nullspace basis is emplyed for synthesis.  The orders of the basis vectors employed for the synthesis are provided in info.deg and info.deg2 (see below).  If simple = false (default), then no simple basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\nscale2 = σ2 specifies the scaling factor σ2 to be employed for the components  Q2(λ) and R2(λ) in (1), i.e.,  use  σ2*Q2(λ) and σ2*R2(λ) instead of Q2(λ) and R2(λ).  (default: σ2 is chosen to ensure the minimum gap provided by Q1(λ)) \n\nfreq = val specifies the values of a test frequency to be employed to check the  full row rank admissibility condition (default: randomly generated in the interval (0,1)).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax of  the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\ngamma = γ specifies the allowed upper bound for ∥Rw(λ)∥∞ (default: γ = 1).\n\nepsreg = ϵ specifies the value of the regularization parameter ϵ (default: ϵ = 0.1)\n\nsdegzer = δ specifies the prescribed stability degree δ for zeros shifting    (default: δ = −0.05 for a continuous-time system sysf.sys and     δ = 0.95 for a discrete-time system sysf.sys).\n\nnonstd = job specifies the option to handle nonstandard optimization problems, as follows:\n\n  job = 1 – use the quasi-co-outer–co-inner factorization (default);\n  job = 2 – use the modified co-outer–co-inner factorization with the\n            regularization parameter `ϵ`;\n  job = 3 – use the Wiener-Hopf type co-outer–co-inner factorization;\n  job = 4 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            zero shifting of the non-minimum phase factor using the\n            stabilization parameter `δ`;\n  job = 5 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            the regularization of the non-minimum phase factor using the\n            regularization parameter `ϵ`.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, degs2, S, S2, HDesign, HDesign2, freq, gap), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G1(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G1(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal.  This information has been used in the case  minimal = true to determine the least order of components Q1(λ) and R1(λ) in (1).\n\ninfo.degs2 is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G2(λ) := [ Gu(λ) Gd(λ) Gw(λ); I 0 0] (also the left Kronecker indices of G2(λ)), if the  state-space realization of [Gu(λ) Gd(λ) Gw(λ)] is minimal.  This information has been used in the case  minimal = true to determine the least order of components Q2(λ) and R2(λ) in (1).\n\ninfo.S is the binary structure matrix of the reduced system  corresponding to the computed left nullspace basis of G1(λ) := [ Gu(λ) Gd(λ); I 0];\n\ninfo.S2 is the binary structure matrix of the reduced system  corresponding to the computed left nullspace basis of G2(λ) := [ Gu(λ) Gd(λ)  Gw(λ); I 0 0];\n\ninfo.HDesign is the design matrix H1 employed for the synthesis of     the components Q1(λ) and R1(λ) in (1) of the fault detection filter;\n\ninfo.HDesign2 is the design matrix H2 employed for the synthesis of  the components Q2(λ) and R2(λ) in (1) of the fault detection filter;\n\ninfo.freq is the frequency value employed to check the full  row rank admissibility condition;\n\ninfo.gap is the achieved gap ∥Rf(λ)∥∞−/∥Rw(λ)∥∞, where the H−minus index is computed over the whole frequency range, if FDfreq = missing, or over the frequency values contained in freq if FDfreq = freq.\n\nMethod: An extension of the Procedure AFD from [1] is implemented to solve  the approximate fault detection problem (see also [2] and Remark 5.10 of [1]).  The employed regularization approach, based on the modified co-outer-co-inner  factorization, is discussed in [3], see also Remark 5.8 of [1].  For the details of the implemented method, see the documentation of the afdsyn function in [4]. \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.3.\n\n[2] A. Varga, General computational approach for optimal fault detection.                Proc. IFAC Symposium SAFEPROCESS, Barcelona, Spain, pp. 107–112, 2009.\n\n[3] K. Glover and A. Varga, On solving non-standard H-/H_2/inf fault detection problems.                Proc. IEEE CDC, Orlando, FL, USA, pp. 891–896, 2011.\n\n[4] A. Varga, Fault Detection and Isolation Tools (FDITOOLS) User's Guide,                arXiv:1703.08480. \n\n\n\n\n\nafdsyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, exact = false, \n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true)  \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection and isolation problem (AFDIP) for a given synthesis model sysf with additive faults and a given binary structure vector SFDI.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the AFDIP, and its internal form, respectively,  and are determined such that the transfer function matrix of  R.sys[:,faults] has its j-th column nonzero if SFDI[j] = 1.  If the solution of a strong AFDIP is feasible, then the j-th column is zero if SFDI[j] = 0.  If only a the solution of a  weak AFDIP is feasible, then the j-th column may be nonzero if SFDI[j] = 0.  For the description of the keyword parameters see the function afdsyn. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.afdisyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.afdisyn","text":"afdisyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, separate = false,\n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection and isolation problem (AFDIP) for a given synthesis model sysf with additive faults and a given binary structure matrix SFDI with nb rows (specifications).  The computed stable and proper filter objects Q and R contain the  fault detection and isolation filter, representing the solution of the AFDIP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.degs2, info.HDesign,  info.HDesign2 andinfo.gap contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection and isolation filter object Q, contains in Q.sys the resulting bank of nb filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i, the i-th component (scalar or vector)  of the overall residual vector r := [r_1; r_2; ...; r_nb].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u   ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the i-th residual component.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter in internal form object R, contains R.sys, the resulting bank of nb  internal form of the filters.   The i-th filter R.sys[i] is in a standard state-space form, which generates the residual signal r_i, and corresponds to the  input-output form\n\n   r_i = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | := |Qyi(λ) Qui(λ)]*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                             |   I     0     0     0     0   |\n\nThe solution of the AFDIP ensures that for the i-th filter, Rui(λ) = 0, Rdi(λ) = 0,  Rfi(λ) has its j-th column nonzero if the (i,j)-th element of SFDI is nonzero,  and the H∞-norm of Rwi(λ) satisfies ||Rwi(λ)||∞ < γ, where the bound γ is  specified via the keyword argument gamma. The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe transfer function matrices Qi(λ) := [ Qyi(λ) Qui(λ) ] and Ri(λ) := [ Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) ]  of the i-th components of the resulting filters Q.sys and R.sys, respectively, have, in general, the partitioned forms\n\n Qi(λ) = [ Q1i(λ) ] ,   Ri(λ) = [ R1i(λ) ] ,                      (1)\n         [ Q2i(λ) ]             [ R2i(λ) ]\n\nwhere the filters Q1i(λ) and R1i(λ) with q1i outputs are the solution of an  AFDP, while the filters Q2i(λ) and R2i(λ) with q2i outputs are the solution of an   exact fault detection problem formulated for a reduced system obtained   by decoupling the control and disturbance inputs from the residuals (see [4]).   The overall resulting component filters Q.sys[i] and R.sys[i] have observable state-space  realizations (AQi,BQi,CQi,DQi) and (AQi,BRi,CQi,DRi), respectively, and thus   share the observable pairs (AQi,CQi). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter synthesis is performed to determine each of the component filters Q.sys[i] and R.sys[i] for i = 1, ...,nb, while  with minimal = false full order synthesis is performed.  \n\nIf exact = true, an exact synthesis (without optimization) is performed, while  with exact = false (default), an approximate synthesis is performed.  \n\nIf HDesign = H1, then H1 is an nb-dimensional array of full row rank or empty design matrices, where H1[i] is the design matrix employed for the synthesis   of the components Q1i(λ) and R1i(λ) in (1) of the i-th filter  (default: HDesign = missing)\n\nIf HDesign2 = H2, then H2 is an nb-dimensional array of full row rank or empty design matrices,  where H2[i] is the design matrix employed for the synthesis  of the components Q2i(λ) and R2i(λ) in (1) of the i-th filter   (default: HDesign2 = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filters Q.sys[i] and R.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. If rdim = missing, the default value of q[i] is chosen as q[i] = q1i + q2i, where  the default values of q1i and q2i are chosen taking into account the rank rwi  of Rwi(λ) in the reduced system (see [2]),  as follows:  if HDesign = missing, then   q1i = min(1,rwi), if minimal = true, or q1i = rwi, if minimal = false;  if HDesign = H1, then q1i is the row dimension of the nonemty design matrix H1[i], or if H1[i] is empty, the above choice for HDesign = missing is employed; if HDesign2 = missing, then   q2i = 1-min(1,rwi), if minimal = true, or q2i is set to its maximum achievable value,  if minimal = false (see [1]);  if HDesign2 = H2, then q2i is the row dimension of the nonemty design matrix H2[i], or  if H2[i] is empty, the above choice for HDesign2 = missing is employed.\n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used at the  initial reduction step, if separate = false,  or at all synthesis steps, if separate = true. If nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step, if separate = false, or at all synthesis steps, if separate = true. This option can  only be used for a proper system without disturbance inputs. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  If simple = false (default), then no simple bases are computed. \n\nIf separate = false (default), a two-step synthesis procedure is employed,  where a minimal proper nullspace basis is used at the  initial reduction step.  If separate = true, the filter components are separately determined by solving appropriately formulated fault detection problems. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nscale2 = σ2 specifies the vector of scaling factors σ2 to be employed for the components  Q2i(λ) and R2i(λ) in (1), i.e.,  use  σ2[i]*Q2i(λ) and σ2[i]*R2i(λ) instead of Q2i(λ) and R2i(λ).  (default: For scale2 = missing, each σ2[i] is chosen to ensure the minimum gap provided by Q1i(λ)) \n\ngamma = γ specifies the allowed upper bound for the resulting ∥Rwi(λ)∥∞ (default: γ = 1).\n\nepsreg = ϵ specifies the value of the regularization parameter ϵ used in afdsyn (default: ϵ = 0.1)\n\nsdegzer = δ specifies the prescribed stability degree δ for zeros shifting    (default: δ = −0.05 for a continuous-time system sysf.sys and     δ = 0.95 for a discrete-time system sysf.sys).\n\nnonstd = job specifies the option to handle nonstandard optimization problems in afdsyn, as follows:\n\n  job = 1 – use the quasi-co-outer–co-inner factorization (default);\n  job = 2 – use the modified co-outer–co-inner factorization with the\n            regularization parameter `ϵ`;\n  job = 3 – use the Wiener-Hopf type co-outer–co-inner factorization;\n  job = 4 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            zero shifting of the non-minimum phase factor using the\n            stabilization parameter `δ`;\n  job = 5 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            the regularization of the non-minimum phase factor using the\n            regularization parameter `ϵ`.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, HDesign, HDesign2, freq, gap), where:\n\ninfo.tcond is an nb-dimensional vector, whose i-th component is the maximum of the condition numbers of the employed  non-orthogonal transformation matrices employed for the synthesis of the i-th filter component;  a warning is issued if any info.tcond[i] >= tcmax;\n\ninfo.HDesign = H1 is an nb-dimensional vector of design matrices,  whose i-th component H1[i] is the design matrix to be employed for the synthesis  of the components Q1i(λ) and R1i(λ) in (1) of  the i-th fault detection filter.\n\ninfo.HDesign2 = H2 is an nb-dimensional vector of design matrices,  whose i-th component H2[i] is the design matrix to be employed for the synthesis  of the components Q2i(λ) and R2i(λ) in (1) of   the i-th fault detection filter.\n\ninfo.freq is the frequency value employed to check the full  row rank admissibility condition.\n\ninfo.gap is an nb-dimensional vector, whose i-th component is the  achieved gap for the synthesis of the i-th filter component.\n\nMethod: The Procedure AFDI from [1] is implemented to solve  the approximate fault detection and isolation problem. For implementation details, see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.5.\n\n[2] A. Varga, Fault Detection and Isolation Tools (FDITOOLS) User's Guide,                arXiv:1703.08480. \n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = FaultDetectionTools\nDocTestSetup = quote\n    using FaultDetectionTools\nend","category":"page"},{"location":"index.html#FaultDetectionTools.jl","page":"Home","title":"FaultDetectionTools.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The FaultDetectionTools.jl package (or shortlyFDITools) is a collection of Julia functions for the analysis and solution  of fault detection problems. The functions of this collection relies on  the DescriptorSystems package [2], whose underlying computational functions are based on the MatrixPencils.jl [3] and MatrixEquations.jl [4] packages. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The implemented functions are based on the computational procedures described in Chapters 5, 6 and 7 of the book:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga, \"Solving Fault Diagnosis Problems, Linear Synthesis Techniques\", vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, xxviii+394, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This book describes the mathematical background of solving synthesis problems of fault detection and model detection filters and gives detailed descriptions of the underlying synthesis procedures. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The targetted functionality parallels the functionality of the MATLAB collection of tools FDITOOLS, whose User's Guide of the version V1.0 is provided in the file fditoolsdoc.pdf.   Supplementary information on the targetted functionality is also available on arXiv in the documentation of the companion MATLAB FDITOOLS collection.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The available functions in the current version of the FaultDetectionTools.jl package are:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Building fault detection and isolation related objects","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FDIModel  Fault detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDIFilter  Fault detection and isolation filter object.\nFDFilterIF  Fault detection filter internal form object.\nFDIFilterIF  Fault detection and isolation filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.\nfdIFeval  Evaluation of the internal forms of fault detection and isolation filters. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Performance evaluation of FDI filters","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdiscond  Computation of the fault detection sensitivity condition.\nfdif2ngap  Computation of the fault-to-noise gap.\nfdimmperf  Computation of the model-matching performace.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solving fault detection and isolation problems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"efdsyn  Exact synthesis of fault detection filters.\nefdisyn  Exact synthesis of fault detection and isolation filters.\nafdsyn  Approximate synthesis of fault detection filters.\nafdisyn  Approximate synthesis of fault detection and isolation filters.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FDI related computational utilities","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fdhinfminus  Evaluation of the H∞- index of the transfer function matrix of a descriptor system model.  \nfdhinfmax  Evaluation of the maximum of column norm of the transfer function matrix of a descriptor system model.  \nfditspec_  Computation of the weak or strong structure matrix of a descriptor system model.\nfdisspec_  Computation of the strong structure matrix of a descriptor system model.\nfdiscond_  Computation of the column-gains sensitivity condition of the transfer function matrix of a descriptor system model.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/FaultDetectionTools.jl/blob/main/ReleaseNotes.md)","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[2]  A. Varga, DescriptorSystems.jl: Manipulation of generalized state-space (descriptor) system representations. Zenodo: https://doi.org/10.5281/zenodo.5148319.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[4]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"},{"location":"makeindex.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html","page":"Index","title":"Index","text":"Pages = [ \"FDIObjects.md\",\n          \"FDIanalysis.md\",\n          \"FDIperformance.md\",\n          \"FDIsynthesis.md\",\n          \"FDIutils.md\" ]\nModule = [\"FaultDetectionTools\"]\nOrder = [:type, :function]","category":"page"}]
}
