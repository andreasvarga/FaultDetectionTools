var documenterSearchIndex = {"docs":
[{"location":"makeindex.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html","page":"Index","title":"Index","text":"Pages = [ \"FDIObjects.md\",\n          \"FDIanalysis.md\",\n          \"FDIperformance.md\",\n          \"FDIsynthesis.md\",\n          \"FDIutils.md\" ]\nModule = [\"FaultDetectionTools\"]\nOrder = [:type, :function]","category":"page"},{"location":"FDIObjects.html#Building-fault-detection-and-isolation-related-objects","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"","category":"section"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel  Fault detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDIFilter  Fault detection and isolation filter object.\nFDFilterIF  Fault detection filter internal form object.\nFDIFilterIF  Fault detection and isolation filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.\nfdIFeval  Evaluation of the internal forms of fault detection and isolation filters. ","category":"page"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel\nfdimodset\nFDFilter\nFDFilter(::DescriptorSystems.DescriptorStateSpace, ::Int, ::Int)\nFDFilterIF\nFDFilterIF(::DescriptorSystems.DescriptorStateSpace, ::Int, ::Int, ::Int)\nFDIFilter\nFDIFilter(::Array{DescriptorSystems.DescriptorStateSpace{T},1}, ::Int, ::Int) where T\nFDIFilterIF\nFDIFilterIF(::Array{DescriptorSystems.DescriptorStateSpace{T},1}, ::Int, ::Int, ::Int) where T\nfdIFeval","category":"page"},{"location":"FDIObjects.html#FaultDetectionTools.FDIModel","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIModel","text":"FDIModel <: AbstractFDDObject\n\nType for synthesis models employed to solve fault detection and isolation problems.\n\nIf sysf::FDIModel is the synthesis model object, the underlying descriptor system model can be obtained via sysf.sys and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in sysf.controls, sysf.disturbances, sysf.faults,  sysf.noise and sysf.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.fdimodset","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.fdimodset","text":"fdimodset(sys; controls, c, disturbances, d, faults, f, fa, faults_sen, fs, noise, n, aux) -> sysf::FDIModel\n\nBuild for a given linear time-invariant system model sys = (A-λE,B,C,D), a synthesis model object sysf::FDIModel  to be used in conjunction with the analysis and synthesis functions of FDI filters.  If sys is a vector of system models, then sysf results as a vector of synthesis model objects.\n\nThe information on the partition of the input components in control, disturbance, fault, noise and auxiliary inputs can be specified using the following keyword arguments:\n\ncontrols = inpu or c = inpu specifies the indices inpu of the control inputs (default: void)\n\ndisturbances = inpd or d = inpd specifies the indices inpd of the disturbance inputs (default: void)\n\nfaults = inpf or f  = inpf specifies the indices inpf of the fault inputs (default: void)\n\nfa = inpfa specifies the indices inpfa of control inputs subject to actuator fault (default: void)\n\nfaults_sen = inpfs or fs = inpfs specifies the indices inpfs of the system outputs subject to sensor fault inputs (default: void)\n\nnoise = inpn or  noise = inpn specifies the indices inpn of the noise inputs (default: void)\n\naux = inpa specifies the indices inpa of the auxiliary inputs (default: void)\n\nThe indices of inputs or outputs can be specified as integer vectors, integer scalars or integer UnitRanges.\n\nThe resulting sysf contains the partitioned system  sysf.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]), where  Bu, Bd, Bf, Bw and Bv are the input matrices from the control inputs u, disturbance inputs d, fault inputs f,  noise inputs w and auxiliary inputs v, respectively, and Du, Dd, Df, Dw and Dv are the feedthrough matrices from those inputs. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nNote: If \n\nMethod: If G(λ) is the p x m transfer function matrix of sys, then the resulting system sysf has an  equivalent input output form [Gu(λ) Gd(λ) Gf(λ) Gw(λ) Gv(λ)], where the following relations define the component matrices: Gu(λ) = G(λ)*Su, Gd(λ) = G(λ)*Sd,  Gf(λ) = [G(λ)*Sf Ss], Gw(λ) = G(λ)*Sw,  Gv(λ) = G(λ)*Sv, with the selection matrices Su, Sd, Sf, Sw and Sv formed from the columns of the m-th order identity matrix and  Ss is formed  from the columns of the p-th order identity matrix. \n\n\n\n\n\n","category":"function"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter <: AbstractFDDObject\n\nType for fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilter is the fault detection filter object, the underlying descriptor system model can be obtained via filter.sys and the indices of output and control inputs  can be accessed as the integer vectors  contained in filter.outputs and filter.controls, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter-Tuple{DescriptorStateSpace, Int64, Int64}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter(sys, p, mu) -> Q::FDFilter\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter object Q, as determined with the synthesis functions of FDI filters.  p and mu are the number of measured outputs and the number of control inputs, respectively.  It is assumed that B = [By Bu Bv] and D = [Dy Du Dv] are partitioned matrices such that By and Dy have p columns, and Bu and Du have mu columns,  where By and Bu are the input matrices from the measured outputs y and  control inputs u, Dy and Du are the feedthrough matrices from the measured outputs y and  control inputs u. \n\nThe resulting Q contains the partitioned system  Q.sys = (A-λE,[By Bd],C,[Dy Du]) and the indices of inputs corresponding  to the measured outputs and control inputs are contained in the associated  integer vectors Q.outputs and Q.controls. \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF <: AbstractFDDObject\n\nType for the internal form of fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilterIF is the fault detection filter internal form object,  the underlying descriptor system model can be obtained via filter.sys and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in filter.controls, filter.disturbances, filter.faults,  filter.noise and filter.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF-Tuple{DescriptorStateSpace, Int64, Int64, Int64}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF(sys, mu, md, mf, mw = 0, maux = 0; moff = 0 ) -> R::FDFilterIF\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter internal form object R, as determined with the synthesis functions of FDI filters.  mu, md, mf, mw and maux are the dimensions of control, disturbance, fault, noise and auxiliary input vectors, respectively. It is assumed that B = [Boff Bu Bd Bf Bw Bv] and D = [Doff Du Dd Df Dw Dv] are partitioned matrices such that Boff and Doff have moff columns, Bu and Du have mu columns, Bd and Dd have md columns,  Bf and Df have mf columns,  Bw and Dw have mw columns, and Bv and Dv have maux columns.   \n\nThe resulting R contains the partitioned system  R.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]) and the indices of inputs corresponding  to the control, disturbance, fault, noise and auxiliary inputs are contained in the associated  integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux.  \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilter","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilter","text":"FDIFilter <: Vector{AbstractFDDObject}\n\nType for fault detection and isolation filters resulted as solutions of fault detection and isolation problems.\n\nIf filter::FDIFilter is the fault detection and isolation filter object,  the underlying i-th descriptor system models can be obtained via filter.sys[i] and the indices of output and control inputs  can be accessed as the integer vectors  contained in filter.outputs and filter.controls, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilter-Union{Tuple{T}, Tuple{Array{DescriptorStateSpace{T}, 1}, Int64, Int64}} where T","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilter","text":"FDIFilter(sys, p, mu) -> Q::FDIFilter\n\nBuild for a vector of linear time-invariant descriptor system models sys[i] = (Ai-λEi,Bi,Ci,Di) with the same number of inputs, a fault detection and isolation filter object Q,  as determined with the synthesis functions of FDI filters.  p and mu are the number of measured outputs and the number of control inputs, respectively.  It is assumed that each Bi = [Byi Bui Bvi] and Di = [Dyi Dui Dvi] are partitioned matrices such that Byi and Dyi have p columns, and Bui and Dui have mu columns,  where Byi and Bui are the input matrices from the measured outputs y and  control inputs u, Dyi and Dui are the feedthrough matrices from the measured outputs y and  control inputs u. \n\nThe resulting Q contains the vector of partitioned systems Q.sys[i] = (Ai-λEi,[Byi Bdi],Ci,[Dyi Dui]) and the indices of inputs corresponding  to the measured outputs and control inputs are contained in the associated  integer vectors Q.outputs and Q.controls. \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilterIF","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilterIF","text":"FDIFilterIF <: AbstractFDDObject\n\nType for the internal form of fault detection and isolation filters resulted as solutions of fault detection and isolation problems.\n\nIf filter::FDIFilterIF is the fault detection and isolation filter internal form object,  the underlying i-th descriptor system models can be obtained via filter.sys[i] and the indices of control, disturbance, fault, noise  and auxiliary inputs can be accessed as the integer vectors  contained in filter.controls, filter.disturbances, filter.faults,  filter.noise and filter.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilterIF-Union{Tuple{T}, Tuple{Array{DescriptorStateSpace{T}, 1}, Int64, Int64, Int64}} where T","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilterIF","text":"FDIFilterIF(sys, mu, md, mf, mw = 0, maux = 0; moff = 0 ) -> R::FDIFilterIF\n\nBuild for a a vector of linear time-invariant descriptor system models sys[i] = (Ai-λEi,Bi,Ci,Di)  with the same number of inputs, ,  a fault detection and isolation filter internal form object R, as determined with the synthesis functions of FDI filters.  mu, md, mf, mw and maux are the dimensions of control, disturbance, fault, noise and auxiliary input vectors, respectively. It is assumed that each Bi = [Boffi Bui Bdi Bfi Bwi Bvi] and Di = [Doffi Dui Ddi Dfi Dwi Dvi] are partitioned matrices such that Boffi and Doffi have moff columns, Bui and Dui have mu columns, Bdi and Ddi have md columns,  Bfi and Dfi have mf columns,  Bwi and Dwi have mw columns, and Bvi and Dvi have maux columns.   \n\nThe resulting R contains the vector of partitioned systems  R.sys[i] = (A-λE,[Bui Bdi Bfi Bwi Bvi],C,[Dui Ddi Dfi Dwi Dvi]) and the indices of inputs corresponding  to the control, disturbance, fault, noise and auxiliary inputs are contained in the associated  integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux.  \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.fdIFeval","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.fdIFeval","text":"fdIFeval(sysQ::FDFilter, sysf::FDIModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::FDFilterIF\n\nCompute the internal form sysR of the fault detection filter sysQ applied to the synthesis model sysf.  If sysf has the partitioned transfer function matrix G(λ) = [ Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) ] in accordance with the partitioned system inputs as controls, disturbances, faults, noise and auxiliary inputs, respectively, and Q(λ) = [ Qy(λ) Qu(λ) ] is the partitioned transfer function matrix of the fault detection filter sysQ  in accordance with the partitioned filter inputs as outputs and controls, then  the transfer function matrix R(λ) of the resulting internal form sysR is given by\n\n R(λ) = | Qy(λ)  Qu(λ) | * | Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) |\n                           |  I       0     0     0     0   |\n\nA minimal descriptor realization is computed if minimal = true and a possibly non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Ar-λEr,Br,Cr,Dr) is the full order descriptor realization of sysR.sys, then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ar, Br, Cr, Dr, the absolute tolerance for the nonzero elements of Er,   and the relative tolerance for the nonzero elements of Ar, Br, Cr, Dr and Er. The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sysR.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\nfdIFeval(sysQ::FDIFilter, sysf::FDIModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::FDIFilterIF\n\nCompute the internal form sysR of the fault detection and isolation filter sysQ applied to the synthesis model sysf.  If sysf has the partitioned transfer function matrix G(λ) = [ Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) ] in accordance with the partitioned system inputs as controls, disturbances, faults, noise and auxiliary inputs, respectively, and Qi(λ) = [ Qyi(λ) Qui(λ) ] is the partitioned transfer function matrix of the i-th filter sysQ.sys[i]  in accordance with the partitioned filter inputs as outputs and controls, then  the transfer function matrix Ri(λ) of the i-th filter in the resulting internal form sysR.sys[i] is given by\n\n Ri(λ) = | Qyi(λ)  Qui(λ) | * | Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) |\n                              |  I       0     0     0     0   |\n\nMinimal descriptor realizations are computed if minimal = true and a possibly non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Ari-λEri,Bri,Cri,Dri) is the full order descriptor realization of sysR.sys[i], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ari, Bri, Cri, Dri, the absolute tolerance for the nonzero elements of Eri,   and the relative tolerance for the nonzero elements of Ari, Bri, Cri, Dri and Eir. The default relative tolerance is ni*ϵ, where ϵ is the working machine epsilon  and ni is the order of the system sysR.sys[i].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"FDIanalysis.html#Analysis-of-FDI-synthesis-models","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"","category":"section"},{"location":"FDIanalysis.html","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"fdigenspec  Generation of achievable FDI specifications.\nfdichkspec  Feasibility analysis of a set of FDI specifications.","category":"page"},{"location":"FDIanalysis.html","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"fdigenspec\nfdichkspec","category":"page"},{"location":"FDIanalysis.html#FaultDetectionTools.fdigenspec","page":"Analysis of FDI synthesis models","title":"FaultDetectionTools.fdigenspec","text":"S = fdigenspec(sysf::FDIModel; sdeg, FDtol, FDGainTol, FDfreq, atol, atol1, atol2, atol3, rtol, fast = true)\n\nGenerate all achievable specifications S for a given synthesis model sysf with additive faults.  Each row of the resulting binary matrix S contains a nonzero specification (or fault signature) which can be achieved using a linear fault detection filter (e.g., as obtainable with the help of function efdisyn).\n\nFDFreq = freq specifies a vector of real frequency values or a scalar real frquency value for strong detectability checks (default: FDFreq = missing).\n\nFDtol = tol1 specifies the threshold tol1 for assessing weak specifications                       (see also function fditspec) (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for assessing strong specifications,   i.e., the threshold for nonzero frequency responce gains for all frequency values specified in freq (see also function fdisspec) (default: tol2 = 0.01). \n\nThe keyword argument sdeg = β specifies a prescribed stability degree β for the poles of the internally  generated candidate filters, such that the real parts of filters poles must be less than or equal to β, in the continuous-time case, and  the magnitudes of filter poles must be less than or equal to β, in the discrete-time case. If sdeg = missing then no then no stabilization is performed if and FDFreq = missing. If sdeg = missing and FDFreq = freq, then the fllowing default values are employed : β = -0.05, in continuous-time case, and  β = 0.95,  in discrete-time case. \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nMethod: The Procedure GENSPEC from [1] is implemented.  The nullspace method [2] is recursively employed to generate candidate fault detection and isolation filters, whose internal forms provide the structure matrices corresponding to the achievable weak specifications, if freq = missing,  or strong specifications for the frequencies conatined in freq. The generation method is also described in [3].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.       Springer Verlag, 2017; sec. 5.4.\n\n[2] A. Varga, On computing nullspace bases – a fault detection perspective.        Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n[3] A. Varga, On computing achievable fault signatures. Proc. SAFEPROCESS'2009, Barcelona, Spain. \n\n\n\n\n\n","category":"function"},{"location":"FDIanalysis.html#FaultDetectionTools.fdichkspec","page":"Analysis of FDI synthesis models","title":"FaultDetectionTools.fdichkspec","text":"fdichkspec(sysf::FDIModel, SFDI::BitMatrix; sdeg, FDtol, FDGainTol, FDfreq, \n             atol, atol1, atol2, atol3, rtol, fast = true, minimal = false) -> (rdims, orders, leastorders)\n\nCheck for a given synthesis model sysf::FDIModel the feasibility of a set of fault detection and isolation specifications SFDI.  If SFDI has N rows (i.e., contains N specifications), then the N-dimensional integer vectors rdims, orders, leastorders  are returned and contain information related to the synthesis of FDI filters to achieve the feasible specifications.  For the i-th specification contained in SFDI[i,:], rdims[i] contains the number of residual  outputs of a minimal nullspace basis based FDI filter which can be used to achieve this specification.  If rdims[i] = 0, then the i-th specification is not feasible. For a feasible i-th specification, orders[i]  contains the order of the minimal nullspace basis based FDI filter which can be used to achieve this specification.  If the i-th specification is not feasible, then orders[i] is set to -1. If minimal = true, leastorders[i] contains the least achievable order for a scalar output FDI filter which can be used   to achieve the i-th specification. If minimal = false or if the i-th specification is not  feasible, then leastorders[i] is set to -1.\n\nFDFreq = freq specifies a vector of real frequency values or a scalar real frquency value for strong detectability checks (default: FDFreq = missing).\n\nFDtol = tol1 specifies the threshold tol1 for assessing weak specifications                       (see also function fditspec) (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for assessing strong specifications,   i.e., the threshold for nonzero frequency responce gains for all frequency values specified in freq (see also function fdisspec) (default: tol2 = 0.01). \n\nThe keyword argument sdeg = β specifies a prescribed stability degree β for the poles of the internally  generated candidate filters, such that the real parts of filters poles must be less than or equal to β, in the continuous-time case, and  the magnitudes of filter poles must be less than or equal to β, in the discrete-time case. If sdeg = missing then no then no stabilization is performed if and FDFreq = missing. If sdeg = missing and FDFreq = freq, then the fllowing default values are employed : β = -0.05, in continuous-time case, and  β = 0.95,  in discrete-time case. \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nMethod: The nullspace method of [1] is successively employed to  determine FDI filters as minimal left nullspace bases which solve  suitably formulated fault detection problems. \n\nReferences:\n\n[1] A. Varga, On computing nullspace bases – a fault detection perspective.        Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#Performance-evaluation-of-FDI-filters","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"","category":"section"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdiscond  Computation of the fault detection sensitivity condition.\nfdif2ngap  Computation of the fault-to-noise gap.\nfdimmperf  Computation of the model-matching performace.","category":"page"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec\nfdisspec\nfdiscond\nfdif2ngap\nfdimmperf","category":"page"},{"location":"FDIperformance.html#FaultDetectionTools.fditspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fditspec","text":"S = fditspec(sysr::FDFilterIF; FDfreq = missing, block = false, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the transfer function matrix Rf(λ) of  the transfer channel from the fault inputs to residuals of  a fault detection filter internal form object sysr::FDFilterIF.   For a filter sysr with q residual outputs and mf fault inputs,  Rf(λ) is the q x mf transfer function matrix of the fault inputs channel with the descriptor system representation sysr.sys[:,sysr.faults] := (Af-lambda*Ef,Bf,Cf,Df). \n\nIf FDfreq = missing (default), then S contains the weak structure matrix of Rf(λ).  For block = false, S is determined as a q x mf  binary matrix (BitMatrix), whose (i,j)-th element is S[i,j] = 1, if the (i,j)-th element of Rf(λ) is  nonzero, and otherwise, S[i,j] = 0.  For block = true, S is determined as a 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of Rf(λ) is nonzero, and otherwise, S[1,j] = 0. \n\nIf FDfreq = freq specifies a vector freq of nf real frequencies  which characterize the classes of persistent fault signals, then  for a suitable proper and invertible M(λ) (see below),   S contains the strong structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts. \n\nFDtol = tol1 specifies an absolute threshold tol1 for the magnitudes of nonzero elements in the system matrices  Bf and Df and is used to determine the weak structure matrix.  Its default value is tol1 = 0.0001*max(1, norm(Bf,1), norm(Df,1)). \n\nFDStol = tol2 specifies an absolute  threshold tol2 for the magnitudes of nonzero elements in the system matrices  Af, Ef, Bf, Cf and Df and is used to determine the strong structure matrix.  Its default value is  tol2 = epsm*max(1, norm(Ef,1), norm(Af,1), norm(Bf,1), norm(Cf,Inf), norm(Df,1))),  where epsm is the working machine precision.\n\nFor block = false, then, if poleshift = true, M(λ) is chosen diagonal such that M(λ)*Rf(λ) has no poles in Ω and if poleshift = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as a q x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the (i,j)-th element of M(λ)*Rf(λ)  evaluated for all frequencies in Ω is nonzero, and otherwise, S[i,j] = 0.  \n\nFor block = true, then, if poleshift = true, M(λ) is chosen such that M(λ)*Rf(λ)  as no poles in Ω and if poleshift = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as an 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of M(λ)*Rf(λ) evaluated for all frequencies in Ω is nonzero and otherwise S[1,j] = 0. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nMethod: For the definition of the structure matrix, see [1]. For the determination of the weak structure matrix, minimal realizations are determined for each column of Rf(λ) if block = true or for  each element of Rf(λ) if block = false and the nonzero columns or  elements in each column are identified  (see Corollary 7.1 of [1]). For the determination of the strong structure matrix, minimal realizations are determined for each column of M(λ)*Rf(λ) if block = true or for  each element of M(λ)*Rf(λ) if block = false and  the full rank of the corresponding system matrix is checked for all frequencies in FDfreq (see Corollary 7.2 in [1]) (i.e., the lack of zeros in all frequencies).\n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec.3.4.\n\n\n\n\n\nS = fditspec(sysr::FDIFilterIF; FDfreq = missing, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the global transfer function matrix Rf(λ) of  the transfer channel from the fault inputs to residuals of  a fault detection and isolation filter internal form object sysr::FDIFilterIF.   The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where the fault to residual channel of the i-th filter sysr.sys[i][:,sysr.faults]  has qi residual outputs and mf fault inputs, has the descriptor system representation sysr.sys[i][:,sysr.faults] := (Afi-lambda*Efi,Bfi,Cfi,Dfi) and  Rfi(λ) is the corresponding qi x mf transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)].  For the evaluation of the strong structure matrix, the structure matrix of the stable  transfer function matrix M(λ)*Rf(λ) is determined, with a M(λ) block-diagonal M(λ) = block-diag(M1(λ), M2(λ), ..., MN(λ)), where Mi(λ) is a suitable square and invertible  transfer function matrix (see below). \n\nFDtol = tol1 specifies an absolute threshold tol1 for the magnitudes of nonzero elements in the system matrices  Bf and Df and is used to determine the weak structure matrix.  Its default value is tol1 = 0.0001*max(1, norm(Bf,1), norm(Df,1)). \n\nFDStol = tol2 specifies an absolute  threshold tol2 for the magnitudes of nonzero elements in the system matrices  Af, Ef, Bf, Cf and Df and is used to determine the strong structure matrix.  Its default value is  tol2 = epsm*max(1, norm(Ef,1), norm(Af,1), norm(Bf,1), norm(Cf,Inf), norm(Df,1))),  where epsm is the working machine precision.\n\nIf FDfreq = missing (default), then S contains the weak structure matrix of Rf(λ).  S is determined as a N x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the j-th column of Rfi(λ) is nonzero, and otherwise, S[i,j] = 0. \n\nIf FDfreq = freq specifies a vector freq of nf real frequencies  which characterize the classes of persistent fault signals, then  for a suitable proper and invertible M(λ) (see below),   S contains the strong structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts. \n\nS is determined as a N x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the j-th column of Mi(λ)*Rfi(λ) is nonzero for all frequencies in Ω, and otherwise, S[i,j] = 0.  If poleshift = true, Mi(λ) is chosen such that Mi(λ)*Rfi(λ) has no poles in Ω and if poleshift = false (default), Mi(λ) = I is used and an error is issued if any Rfi(λ) has poles in Ω. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nMethod: For the definition of the structure matrix, see [1]. For the determination of the weak structure matrix, minimal realizations are determined for each column of Rfi(λ) and the nonzero columns are identified  (see Corollary 7.1 of [1]). For the determination of the strong structure matrix, minimal realizations are determined for each column of Mi(λ)*Rfi(λ) and  the full rank of the corresponding system matrix is checked for all frequencies in Ω (see Corollary 7.2 in [1]) (i.e., the lack of zeros in all frequencies in Ω).\n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec.3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdisspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdisspec","text":" S = fdisspec(sysr::FDFilterIF, freq; block = false, stabilize = false, FDGainTol = 0.01, \n                 atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute, for a given set of real frequencies freq,   the strong binary structure matrix S of the stable transfer function matrix M(λ)*Rf(λ),  where Rf(λ) is the transfer function matrix of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF and   M(λ) is a suitable proper and invertible stabilizing transfer function matrix (see below).   For a filter sysr with q residual outputs and mf fault inputs,  Rf(λ) is the q x mf transfer function matrix of the fault inputs channel with the descriptor system representation sysr.sys[:,sysr.faults] := (Af-lambda*Ef,Bf,Cf,Df). \n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent fault signals  (default: freq = 0, i.e., characterizing constant faults). S contains the strong  structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts.  \n\nFDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nFor block = false, then, if stabilize = true, M(λ) is chosen diagonal such that M(λ)*Rf(λ) has only stable poles and if stabilize = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as a q x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the (i,j)-th element of M(λ)*Rf(λ)  evaluated for all frequencies in freq is larger than or equal to tol, and otherwise, S[i,j] = 0.  \n\nFor block = true, then, if stabilize = true, M(λ) is chosen such that M(λ)*Rf(λ)  has only stable poles and if stabilize = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as an 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of M(λ)*Rf(λ) evaluated for all frequencies in Ω is larger than or equal to tol and otherwise, S[1,j] = 0. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,  the absolute tolerance for the nonzero elements of Cf,    and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nMethod: S is evaluated using the definition of the strong structure matrix in [1]. \n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec. 3.4.\n\n\n\n\n\n S = fdisspec(sysr::FDIFilterIF, freq; stabilize = false, FDGainTol = 0.01, \n                 atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute, for a given set of real frequencies freq,   the strong binary structure matrix S  of the stable transfer function matrix M(λ)*Rf(λ), where Rf(λ) is the global  transfer function matrix of the transfer channel from the fault inputs to residuals of the fault detection and isolation filter internal form object sysr::FDIFilterIF and   M(λ) is a suitable block-diagonal proper and invertible stabilizing transfer function matrix (see below).   The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where the fault to residual channel of the i-th filter sysr.sys[i][:,sysr.faults]  has qi residual outputs and mf fault inputs, has the descriptor system representation sysr.sys[i][:,sysr.faults] := (Afi-lambda*Efi,Bfi,Cfi,Dfi) and  Rfi(λ) is the corresponding qi x mf transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)].  M(λ) = block-diag(M1(λ), M2(λ), ..., MN(λ)), where Mi(λ) is square and invertible  and chosen such that Mi(λ)Rfi(λ) is stable (see below). \n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent fault signals  (default: freq = 0, i.e., characterizing constant faults). S contains the strong  structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts.  \n\nFDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nIf stabilize = true, Mi(λ) is chosen such that Mi(λ)*Rfi(λ) has only stable poles and if stabilize = false (default), Mi(λ) = I is used and an error is issued  if any Rfi(λ) has poles in Ω. \n\nS is determined as a N x mf  binary matrix, whose (i,j)-th element is S[i,j] = 1, if the norm of the  j-th column of Mi(λ)*Rfi(λ) evaluated for all frequencies in Ω  is larger than or equal to tol, and otherwise, S[i,j] = 0. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Afi, Bfi, Cfi, Dfi, the absolute tolerance for the nonzero elements of Efi,  the absolute tolerance for the nonzero elements of Cfi,    and the relative tolerance for the nonzero elements of Afi, Bfi, Cfi, Dfi and Efi.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nMethod: S is evaluated using the definition of the strong structure matrix in [1]. \n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec. 3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdiscond","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdiscond","text":" fdiscond(sysr::FDFilterIF,freq) -> (scond, β, γ)\n\nCompute for the stable transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF the quantities:  β - the H∞- index of Rf(λ), γ - the maximum of the columns norms of Rf(λ) and  the fault detection sensitivity condition scond evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n fdiscond(sysr::FDFilterIF,SFDI,freq) -> (scond, β, γ)\n\nCompute the detection and isolation sensitivity condition scond (and related quatities β and γ) for the binary structure vector SFDI associated to the stable transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF.  If  Rff(λ) is the transfer function matrix formed of those j-th columns of Rf(λ)  for which SFDI[j] = 1, then:    β - the H∞- index of Rff(λ), γ - the maximum of the columns norms of Rff(λ) and  the fault detection sensitivity condition scond evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n fdiscond(sysr::FDFilterIF, SFDI, freq) -> (scond, β, γ)\n\nCompute the detection and isolation sensitivity condition vector scond (and related quatities β and γ) for the q × mf binary structure matrix SFDI associated to the stable transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter and  Rfi(λ) is the corresponding transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)]. The i-th element of the vectors scond, β and γ contain the quantities:  β[i] - the H∞- index of the nonzero columns of Rffi(λ), γ - the maximum of the nonzero columns norms of Rfi(λ) and  the correspomding fault detection sensitivity condition scond[i] evaluated as scond[i] := β[i]/γ[i], where Rffi(λ) is formed of those j-th  columns of the i-th row of Rf(λ) for which S[i,j] = 1 and  Rfi(λ) is the i-th row of Rf(λ).  It is assumed that for each j such that SFDI[i,j] = 1, the j-th column of Rfi(λ) is nonzero  and  for each j such that SFDI[i,j] = 0, the j-th column of Rfi(λ) is zero.  If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq. \n\n\n\n\n\n fdiscond(sysr::FDIFilterIF, SFDI, freq) -> (scond, β, γ)\n\nCompute the detection and isolation sensitivity condition scond (and related quatities β and γ) for the N × mf binary structure matrix SFDI associated to the stable global transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter and  Rfi(λ) is the corresponding transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)]. It is assumed that for each j such that SFDI[i,j] = 1, the j-th column of Rfi(λ) is nonzero  and  for each j such that SFDI[i,j] = 0, the j-th column of Rfi(λ) is zero.  The i-th element of the vectors scond, β and γ contain the quantities:  β[i] - the H∞- index of the nonzero columns of Rfi(λ), γ - the maximum of the nonzero columns norms of Rf(λ) and  the fault detection sensitivity condition scond evaluated as scond[i] := β[i]/γ[i].  If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq. \n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdif2ngap","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdif2ngap","text":" fdif2ngap(sysr::FDFilterIF, freq) -> (gap, β, γ)\n\nCompute the fault-to-noise gap gap (and the related quantities β and γ)  for the stable fault detection filter internal form object sysr::FDFilterIF. For the fault to residual channel of the filter sysr.sys[:,sysr.faults]    with the corresponding transfer function matrix Rf(λ) and  the noise to residual channel of the filter sysr.sys[:,sysr.noise]    with the corresponding transfer function matrix Rw(λ),     β is the H∞- index of Rf(λ), γ is the H∞-norm of Rw(λ) and  gap is the fault-to-noise gap evaluated as gap := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq.  gap = ∞ if there are no noise inputs and gap = 0 if there are no fault inputs.\n\n\n\n\n\n fdif2ngap(sysr::FDFilterIF, SFDI, freq) -> (gap, β, γ)\n\nCompute the fault-to-noise gap gap (and the related quantities β and γ)  for the stable fault detection filter internal form object sysr::FDFilterIF and the associated binary structure vector SFDI. sysr.sys[:,sysr.faults] is the fault to residual channel of the filter  with the corresponding transfer function matrix Rf(λ) and  sysr.sys[:,sysr.noise] is the noise to residual channel of the filter  with the corresponding transfer function matrix Rw(λ).    If  Rff(λ) is the transfer function matrix formed of those j-th columns of Rf(λ)  for which SFDI[j] = 1 and Rdf(λ) is the transfer function matrix formed of  those j-th columns of Rf(λ) for which SFDI[j] = false, then:    β is the H∞- index of Rff(λ), γ is the H∞-norm of [Rdf(λ) Rw(λ)] and  gap is the fault-to-noise gap evaluated as gap := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq.  gap = ∞ if [Rdf(λ) Rw(λ)] = 0 and gap = 0 if Rff(λ) = 0.\n\n\n\n\n\n  fdif2ngap(sysr::FDFilterIF, SFDI, freq; atol = √ϵ) -> (gap, β, γ)\n\nCompute the fault-to-noise gap  gap (and the related quatities β and γ) for the q × mf binary structure matrix SFDI associated to the stable transfer function matrices Rf(λ) and Rw(λ) of the transfer channels from the fault inputs to residuals and noise inputs to residuals, respectively,  of the fault detection filter internal form object sysr::FDFilterIF.  The i-th element of the vectors gap, β and γ contain the quantities:  β[i] - the H∞- index of Rffi(λ), γ[i] - the H∞-norm of [Rdfi(λ) Rwi(λ)] and  the fault-to-noise gap gap evaluated as gap[i] := β[i]/γ[i], where Rffi(λ) is formed of those j-th  columns of the i-th row of Rf(λ) for which S[i,j] = 1 and  Rdfi(λ) is formed of those j-th  columns of the i-th row of Rf(λ) for which S[i,j] = 0.  gap[i] = ∞ if [Rdfi(λ) Rwi(λ)] = 0 and gap[i] = 0 if Rffi(λ) = 0. If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq.  atol is an absolute tolerance for the norms Rwi(λ), such that norm values less than or equal to atol are  considered zero (default:  √ϵ, where ϵ is the working machine precision.)\n\n\n\n\n\n fdif2ngap(sysr::FDIFilterIF, SFDI, freq; atol = √ϵ) -> (gap, β, γ)\n\nCompute the fault-to-noise gap  gap (and the related quatities β and γ) for the N × mf binary structure matrix SFDI associated to the stable global transfer function matrices Rf(λ) and Rw(λ) of the transfer channels from the fault inputs to residuals and noise inputs to residuals, respectively,  of the fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter  with the corresponding transfer function matrix Rfi(λ) and sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ).    The global transfer function matrices Rf(λ) and Rw(λ) are formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)] and  Rw(λ) := [ Rw1(λ); Rw2(λ); ...; RwN(λ)]  Let  Rffi(λ) be the transfer function matrix formed of those j-th columns of Rfi(λ)  for which SFDI[i,j] = 1 and let Rdfi(λ) be the transfer function matrix formed of those j-th columns of Rfi(λ)  for which SFDI[i,j] = 0.  The i-th element of the vectors gap, β and γ contain the quantities:  β[i] - the H∞- index of Rffi(λ), γ[i] - the H∞-norm of [Rdfi(λ) Rwi(λ)] and  the fault-to-noise gap gap evaluated as gap[i] := β[i]/γ[i].  gap[i] = ∞ if [Rdfi(λ) Rwi(λ)] = 0 and gap[i] = 0 if Rffi(λ) = 0. If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq.  atol is an absolute tolerance for the norms Rwi(λ), such that norm values less than or equal to atol are  considered zero (default:  √ϵ, where ϵ is the working machine precision.)\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdimmperf","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdimmperf","text":" γ = fdimmperf(sysr::FDFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF.  If Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[:,sysr.noise], then γ is the  H∞-norm of Rw(λ), if nrmflag = Inf (default) and the  H2-norm of Rw(λ), if nrmflag = 2. The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix Rw(λ) of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF for a given binary structure vector SFDI. If Rf(λ) is the transfer function matrix of the  transfer channel from the fault inputs to residuals sysr.sys[:,sysr.faults] and  Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[:,sysr.noise], then γ is the  H∞-norm of [Rdf(λ) Rw(λ)], if nrmflag = Inf (default) and the  H2-norm of [Rdf(λ) Rw(λ)],  if nrmflag = 2, where Rdf(λ) is the transfer function matrix formed by those j-th columns of Rf(λ) for which  SFDI[j] = 0.   The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rdf(λ) Rw(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF for a given binary structure matrix SFDI. If Rf(λ) is the transfer function matrix of the  transfer channel from the fault inputs to residuals sysr.sys[:,sysr.faults] and  Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[:,sysr.noise], then γ is the  H∞-norm of [Rdf(λ) Rw(λ)], if nrmflag = Inf (default) and the  H2-norm of [Rdf(λ) Rw(λ)],  if nrmflag = 2, where Rdf(λ) = .!SFDI .* Rf(λ) (i.e., the element-wise product of .!SFDI and Rf(λ). The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rdf(λ) Rw(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the stable fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ). Then,  γ is an N-dimensional vector whose i-th component is the  H∞-norm of Rwi(λ), if nrmflag = Inf (default)  and the  H2-norm of Rwi(λ), if nrmflag = 2. The i-th component of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix Rwi(λ) of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the stable fault detection and isolation  filter internal form object sysr::FDIFilterIF and the associated binary structure matrix SFDI.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter  with the corresponding transfer function matrix Rfi(λ) and sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ). Then,  γ is an N-dimensional vector whose i-th component is the  H∞-norm of [Rfdi(λ) Rwi(λ)], if nrmflag = Inf (default)  or the  H2-norm of [Rfdi(λ) Rwi(λ)], if nrmflag = 2, where Rfdi(λ) is the transfer function matrix whose j-th column is  zero if SFDI[i,j] = 1 and is equal to the j-th column of Rfi(λ) if SFDI[i,j] = 0.  The i-th component of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rfdi(λ) Rwi(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDFilterIF, sysref::Union{FDFilterIF,FDIModel}[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF with respect to the fault detection reference filter internal form  sysref::FDFilterIF.  If R(λ) is the transfer function matrix of the fault detection filter internal form    sysr.sys and Mr(λ) is the transfer function matrix of the fault detection reference filter internal form    sysref.sys, then γ is the  H∞-norm of R(λ)-Mr(λ), if nrmflag = Inf (default) or the  H2-norm of R(λ)-Mr(λ), if nrmflag = 2. The value of γ is infinite for an unstable difference R(λ)-Mr(λ) or if nrmflag = 2 and the transfer function matrix R(λ)-Mr(λ) of a continuous-time system is not strictly proper. In general, R(λ) and Mr(λ) are partitioned as R(λ) = [ Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) ] and Mr(λ) = [ Mru(λ) Mrd(λ) Mrf(λ) Mrw(λ) Mra(λ) ] in accordance with  the partitioning of the inputs in control inputs, disturbance inputs, fault inputs, noise inputs and auxiliary inputs. Void components of Mr(λ) corresponding to non-void components in R(λ) are assumed to be zero. \n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF, sysref::FDIFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection and isolation filter internal form object sysr::FDIFilterIF with respect to the fault detection and isolation reference filter internal form  sysref::FDIFilterIF.  If Ri(λ) is the transfer function matrix of the i-th fault detection and isolation filter internal form    sysr.sys[i] and Mri(λ) is the transfer function matrix of the i-th fault detection and isolation reference filter internal form    sysref.sys[i], then γ is a vector whose i-th component γ[i] is the  H∞-norm of Ri(λ)-Mri(λ), if nrmflag = Inf (default) or the  H2-norm of Ri(λ)-Mri(λ), if nrmflag = 2. The value of γ[i] is infinite for an unstable difference Ri(λ)-Mri(λ) or if nrmflag = 2 and the transfer function matrix Ri(λ)-Mri(λ) of a continuous-time system is not strictly proper. In general, Ri(λ) and Mri(λ) are partitioned as Ri(λ) = [ Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) ] and Mri(λ) = [ Mrui(λ) Mrdi(λ) Mrfi(λ) Mrwi(λ) Mrai(λ) ] in accordance with  the partitioning of the inputs in control inputs, disturbance inputs, fault inputs, noise inputs and auxiliary inputs. Void components of Mri(λ) corresponding to non-void components in Ri(λ) are assumed to be zero. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FDI-related-utilities","page":"FDI related utilities","title":"FDI related utilities","text":"","category":"section"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdhinfminus  Evaluation of the H∞- index of the transfer function matrix of a descriptor system model.  \nfdhinfmax  Evaluation of the maximum of column norm of the transfer function matrix of a descriptor system model.  \nfditspec_  Computation of the weak or strong structure matrix of a descriptor system model.\nfdisspec_  Computation of the strong structure matrix of a descriptor system model.\nfdiscond_  Computation of the column-gains sensitivity condition of the transfer function matrix of a descriptor system model.","category":"page"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdhinfminus\nfdhinfmax\nfditspec_\nfdisspec_\nfdiscond_","category":"page"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfminus","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfminus","text":" fdhinfminus(sys,freq) -> (β, ind, fr)\n\nCompute for a stable descriptor system sys = (A-λE,B,C,D) the H∞- index β of its transfer function matrix G(λ). If freq = missing (default), then β is the  minimum H∞-norm of the columns of G, ind is the index of the minimum-norm column and fr is  the frequency where the minimum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then β is the minimum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the minimum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfmax","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfmax","text":" fdhinfmax(sys,freq) -> (γ, ind, fr)\n\nCompute for a descriptor system sys = (A-λE,B,C,D), γ - the maximum norm of the columns of its transfer function matrix G(λ). If freq = missing (default), then γ is the  maximum H∞-norm of the columns of G, ind is the index of the maximum-norm column and fr is  the frequency where the maximum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then γ is the maximum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the maximum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fditspec_","page":"FDI related utilities","title":"FaultDetectionTools.fditspec_","text":"S = fditspec_(sysrf::DescriptorStateSpace; FDfreq = missing, block = false, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the transfer function matrix of a  linear time-invariant system sysrf  (typically representing the transfer channel from the fault inputs to residuals). sysrf has a descriptor system realization of the form sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ).  For the description of keyword parameters see the documentation of fditspec. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdisspec_","page":"FDI related utilities","title":"FaultDetectionTools.fdisspec_","text":" fdisspec_(sysrf::DescriptorStateSpace, freq; block = false, stabilize = false, FDGainTol = 0.01, \n                 atol, atol1, atol2, atol3, rtol, fast = true) -> (S, gains)\n\nCompute the strong binary structure matrix S of the transfer function matrix of a  linear time-invariant system sysrf  (typically representing the transfer channel from the fault inputs to residuals). sysrf has a descriptor system realization of the form sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ).  For the description of keyword parameters see the documentation of fdisspec. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdiscond_","page":"FDI related utilities","title":"FaultDetectionTools.fdiscond_","text":" fdiscond_(sysrf::DescriptorStateSpace, freq) -> (scond, β, γ)\n\nCompute for a stable descriptor system sysrf = (A-λE,B,C,D) with the transfer function matrix Rf(λ),  β - the H∞- index of Rf(λ), γ - the maximum of the columns norms of Rf(λ) and  scond - the column-gains sensitivity condition evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n","category":"function"},{"location":"FDDbasics.html#Fault-detection-and-diagnosis-basics","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"","category":"section"},{"location":"FDDbasics.html#Synthesis-models","page":"Fault detection and diagnosis basics","title":"Synthesis models","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The plant models underlying all implemented synthesis methods (also called synthesis models) are linear time-invariant system models, where the faults are equated with special (unknown) disturbance inputs.  An important class of models with additive faults arises when defining the fault signals for two main categories of faults, namely, actuator and sensor faults. Two basic forms of synthesis models are used.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The input-output plant model with additive faults  has the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfy(lambda) = G_u(lambda)mathbfu(lambda) +\nG_d(lambda)mathbfd(lambda) + G_f(lambda)mathbff(lambda) +\nG_w(lambda)mathbfw(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where  mathbfy(lambda), mathbfu(lambda), mathbfd(lambda), mathbff(lambda), and mathbfw(lambda) (with boldface notation), are the Laplace-transformed (in the continuous-time case) or Z-transformed (in the discrete-time case)  p-dimensional system output vector y(t), m_u-dimensional control input vector u(t), m_d-dimensional disturbance vector d(t), m_f-dimensional fault vector f(t) and m_w-dimensional noise vector w(t), respectively, and where G_u(lambda), G_d(lambda), G_f(lambda)   and G_w(lambda) are proper transfer function matrices (TFMs) from the respective inputs to outputs.  Input-output models with additive faults of the above form are useful in formulating various fault diagnosis problems, in deriving general solvability conditions and in describing conceptual synthesis procedures. However, these models are generally not suited for numerical computations, due to the  potentially high sensitivity of polynomial-based model representations.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For computational purposes, instead of the above input-output model with the compound TFM  G_u(lambda)  G_d(lambda)  G_f(lambda)  G_w(lambda) , an equivalent state-space model is used having the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrcl Elambda x(t) = Ax(t) + B_u u(t) + B_d d(t) + B_f f(t) + B_w w(t)    \ny(t) =Cx(t) + D_u u(t) + D_d d(t) +  D_f f(t) + D_w w(t)   \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"with the n-dimensional state vector x(t), where lambda x(t) = dotx(t) or lambda x(t) = x(t+1) depending on the type of the system, continuous- or discrete-time, respectively.  The matrix E is generally invertible and is frequently  taken as E = I_n. Plant models of the above state-space form often arise from the linearization of nonlinear dynamic plant models in specific operation points and for  fixed values of plant parameters. The noise inputs generally  account  for the effects of uncertainties (e.g., inherent  variabilities in operating points and parameters).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"To indicate the input-output equivalence of the two types of models, we use the notation","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" G_u(lambda)  G_d(lambda)  G_f(lambda)  G_w(lambda)  = left beginarrayccccc A-lambda E  B_u  B_d  B_f  B_w   hline\nC  D_u  D_d  D_f  D_w endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"which stays for the following relations between the elements of the two representations:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarraylll G_u(lambda) = C(lambda E-A)^-1B_u+D_u \nG_d(lambda) = C(lambda E-A)^-1B_d+D_d \nG_f(lambda) = C(lambda E-A)^-1B_f + D_f\nG_w(lambda) = C(lambda E-A)^-1B_w + D_w \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The state-space synthesis model underlies the definition of the FDIModel object used in the functions for the synthesis of fault diagnosis filters.","category":"page"},{"location":"FDDbasics.html#Residual-generation","page":"Fault detection and diagnosis basics","title":"Residual generation","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A nonzero fault signal f neq 0 signifies a deviation from the normal behaviour of the plant due to an unexpected event (e.g., physical component failure or supply breakdown). Generally, the occurrence of a fault must be detected as early as possible to prevent further degradation of the plant behaviour. Fault detection and diagnosis (FDD) is concerned with one or more of the following aspects: the detection of the occurrence of any fault (fault detection), the localization of detected faults (fault isolation), the reconstruction of the fault signal (fault estimation) and the classification of the detected faults and determination of their characteristics (fault identification). The later aspect is not addressed in this package. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A FDD system is a device (usually based on a collection of real-time processing algorithms) suitably set-up to fulfill the above tasks.  The main component of any FDD system is the residual generator (or fault detection filter), which produces residual signals grouped in a q-dimensional vector r by processing the available measurements y and the known values of control inputs u. The role of the residual signals is to indicate the presence  or absence of faults, and therefore the residual r must be equal (or close) to zero in the absence of faults and significantly different from zero after a fault occurs.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For decision-making when solving fault detection problems, a suitable measure of the residual magnitude is generated in a scalar evaluation signal theta  (e.g., theta = r), which is then used to set a decision variable, say  iota, as follows: iota= 1, if theta  tau for a detected fault, and iota= 0 if theta leq tau,  for the lack of faults, where tau is a given detection threshold.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For decision-making when solving faul isolation problems, r(t) is generally a structured vector with, say n_b components r^(i)(t), i = 1 ldots n_b, and  theta and iota are n_b-dimensional vectors, with theta_i representing a measure of the magnitude of the i-th residual component (e.g., theta_i = -r^(i)). The i-th component of the binary signature vector iota is set iota_i = 1 or iota_i = 0 corresponding to a fired (i.e, theta_i  tau) or not fired (i.e., theta_i leq tau)  component r^(i)(t), respectively.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A linear residual generator employed in a FDD system  has the input-output form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = Q(lambda)left beginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright = \nQ_y(lambda)mathbfy(lambda) + Q_u(lambda)mathbfu(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where Q(lambda) = Q_y(lambda)  Q_u(lambda) is the TFM of the filter. For a physically realizable filter,  Q(lambda) must be stable (i.e., with all its poles having negative real parts for a continuous-time system or magnitudes less than one for a discrete-time system). The order of Q(lambda) is the dimension of the state vector of a minimal state-space realization of Q(lambda). The dimension q of the residual vector r(t) depends on the fault diagnosis problem to be solved. The above input-output representation is called the implementation form of the fault detection filter and is the basis of its real-time implementation.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The residual signal r(t) generally depends via the system outputs y(t) of all system inputs u(t), d(t), f(t) and w(t). The internal form of the filter is obtained by replacing in the above equation mathbfy(lambda) by its expression in the synthesis model, and is given by","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = R(lambda)left beginarraycmathbfu(lambda)\nmathbfd(lambda)  mathbff(lambda)  mathbfw(lambda)endarrayright =  \nR_u(lambda)mathbfu(lambda) +\nR_d(lambda)mathbfd(lambda) + \nR_f(lambda)mathbff(lambda) + R_w(lambda)mathbfw(lambda)\n","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R(lambda) =  R_u(lambda) mid  R_d(lambda) mid  R_f(lambda) mid  R_w(lambda) = \nQ(lambda)  left beginarraycccc G_u(lambda)  G_d(lambda)  G_f(lambda)   G_w(lambda) \n         I_m_u  0  0  0 endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For a successfully designed filter Q(lambda), all TFMs in the corresponding internal form R(lambda) are  stable, and  fulfil  specific fault diagnosis requirements.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The basic functionality  of a well-designed fault detection filter is to ensure the lack of false alarms, in the case when no faults occurred, and the lack of missed detection of faults, in the case of occurrence of a fault. The first requirement is fulfilled if, in the presence of noise, the signal norm r is  sufficiently small for all possible control, disturbance and noise inputs. The requirement on the lack of missed detections is fulfilled provided r is sufficiently large for any fault of sufficiently large magnitude for all possible control, disturbance and noise inputs.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The fault detection filter in the implementation form underlies the definition of the FDFilter object, while the internal form underlies the definition of the FDFilterIF object. These objects are generated by several synthesis functions. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the isolation of faults, a bank of residual generator filters is employed which is formed by stacking a bank of n_b filters of the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr^(i)(lambda) = Q^(i)(lambda)left beginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where the i-th filter Q^(i)(lambda) generates the corresponding i-th residual component  r^(i)(t) (scalar or vector). The internal form of the i-th filter Q^(i)(lambda) is ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr^(i)(lambda) = R^(i)(lambda)left beginarraycmathbfu(lambda)\nmathbfd(lambda)  mathbff(lambda)  mathbfw(lambda)endarrayright =  \nR^(i)_u(lambda)mathbfu(lambda) +\nR^(i)_d(lambda)mathbfd(lambda) + \nR^(i)_f(lambda)mathbff(lambda) + R^(i)_w(lambda)mathbfw(lambda)\n","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R^(i)(lambda) =  R^(i)_u(lambda) mid  R^(i)_d(lambda) mid  R^(i)_f(lambda) mid  R^(i)_w(lambda) = \nQ^(i)(lambda)  left beginarraycccc G_u(lambda)  G_d(lambda)  G_f(lambda)   G_w(lambda) \n         I_m_u  0  0  0 endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"This leads to the following structured residual vector r(t) and block-structured filters Q(lambda) and R(lambda)","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"r(t) = left beginarrayc r^(1)(t) vdots  r^(n_b)(t) endarrayright  \nQ(lambda) = left beginarrayc Q^(1)(lambda) vdots  Q^(n_b)(lambda) endarrayright    R(lambda) = left beginarrayc R^(1)(lambda) vdots  R^(n_b)(lambda) endarray right  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The above bank of fault detection filters is the basis of the definition of the fault detection and isolation object FDIFilter and its internal form FDIFilterIF.","category":"page"},{"location":"FDDbasics.html#Structure-matrix","page":"Fault detection and diagnosis basics","title":"Structure matrix","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Consider R_f(lambda), the TFM from the fault inputs f to residual r in the internal form, and assume R_f(lambda) is an n_btimes m_f block-structured TFM of the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R_f(lambda) = left beginarrayccc R^(1)_f_1(lambda) cdots R^(1)_f_m_f(lambda) \nvdots  ddots  vdots \n R^(n_b)_f_1(lambda) cdots R^(n_b)_f_m_f(lambda) endarrayright   ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where the (ij)-th block of R_f(lambda) is defined as ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R^(i)_f_j(lambda) = Q^(i)(lambda) left beginarrayc G_f_j(lambda)  0 endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Here, Q^(i)(lambda) is either the i-th row of the filter Q(lambda), in which case R^(i)_f_j(lambda) is the (ij)-th element of R_f(lambda), or the i-th block row of Q(lambda) corresponding to the i-th filter in a bank of n_b filters.  In both cases, R^(i)_f_j(lambda) describes how the j-th fault f_j influences the i-th (scalar or vector) component of the residual r.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"We associate to the block structured R_f(lambda) the n_btimes m_f binary structure matrix S_R_f, whose (ij)-th element is defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayllrll S_R_f(ij) = 1  text if   R^(i)_f_j(lambda) not=0  \nS_R_f(ij) = 0  text if   R^(i)_f_j(lambda) =0  \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"If S_R_f(ij) = 1 then we say that the i-th residual component is sensitive to the j-th fault f_j, while if S_R_f(ij) = 0 then the j-th fault f_j  is decoupled from i-th residual component. The m_f columns of S_R_f are called fault signatures and play a crucial role in the decision making  for fault isolation. Since each nonzero column of S_R_f is associated with the corresponding fault input, fault isolation can be performed by comparing the resulting binary decision vector iota in the FDD system (i.e., the signatures of fired or not fired residual components) with the fault signatures coded in the columns of S_R_f. The rows of S_R_f play an important role in solving FDI synthesis problems and are called specifications. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The above definition of the structure matrix S_R_f is associated with the zero/nonzero blocks of the TFM R_f(lambda) and is also known as the weak structure matrix.  The strong structure matrix is related to the zero/nonzero blocks of the frequency response of R_f(lambda) evaluated for a set of  relevant complex frequencies Omega characterizing the classes of persistent fault inputs. For example, to a real frequency omega which characterizes sinusoidal faults, the corresponding complex frequency in Omega is jomega for a continuous-time system or exp(jomega T_s) for a discrete-time system with sampling time T_s (thus, the null frequency characterizes constant faults). The strong structure matrix is defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayllrll S_R_f(ij) = 1  text if   R^(i)_f_j(lambda_z) not=0   text for all   lambda_z in Omega \nS_R_f(ij) = 0  text if   R^(i)_f_j(lambda_z) = 0  text for any  lambda_z in Omega \nendarray ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the determination of the weak or strong structure matrix  the function fditspec is available. Alternatively, the function fdisspec can be used to determine the strong structure matrix. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving fault isolation problems, the choice of the desired structure matrix S_R_f is an important aspect. The function fdigenspec allows to compute the maximally achievable structure matrix for a given synthesis model. The function fdichkspec can be employed to check the feasibility of a set of FDI specifications.","category":"page"},{"location":"FDDbasics.html#Fault-diagnosis-problems","page":"Fault detection and diagnosis basics","title":"Fault diagnosis problems","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Six basic fault diagnosis problems are formulated in what follows and their solutions are addressed by the implemented synthesis functions. To fulfill the basic requirement for the lack of false alarms in the presence of arbitrary control and disturbance inputs, for all problems we require that by a suitable choice of a stable fault detection filter Q(lambda), we achieve that  the residual signal r(t) is fully decoupled from the control input u(t) and disturbance input d(t). Thus, the following decoupling conditions must be generally fulfilled:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayll\n  (i)  R_u(lambda) = 0 \n  (ii)  R_d(lambda) = 0 \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Since the effect  of a nonzero  noise input w(t) can usually not be fully decoupled from the residual r(t), an additional requirement is that the influence of the noise signal w(t) is negligible. Thus, the following noise attenuation condition has to be also fulfilled:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayll\n (iv)  R_w(lambda) approx 0  textrmwith  R_w(lambda)  textrmstable\nendarray ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The condition R_w(lambda) approx 0 expresses the requirement  that the transfer gain R_w(lambda) (measured by any suitable norm) can be made arbitrarily small and is intended to avoid missed detections in the presence of noise inputs. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For particular fault diagnosis problems specific requirements on R_f(lambda) have to be additionally fulfilled.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"We distinguish between exact and approximate solutions of fault diagnosis problems. The exact problems impose no conditions regarding noise inputs, excepting the stability of R_w(lambda) in the case when w notequiv 0. The approximate problems address the case of nonzero noise inputs by employing special techniques to reduce their effects. For both cases we assume the following general internal form of the filter Q(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"r(lambda) =\nR_u(lambda)mathbfu(lambda) +\nR_d(lambda)mathbfd(lambda)    + R_f(lambda)mathbff(lambda) + R_w(lambda)mathbfw(lambda) ","category":"page"},{"location":"FDDbasics.html#Exact-fault-detection-problem-(EFDP)","page":"Fault detection and diagnosis basics","title":"Exact fault detection problem (EFDP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EFDP: Determine a stable residual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii) R_f_j(lambda) not = 0 j = 1 ldots m_f  textwith  R_f(lambda)  colormagenta textstable \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Condition (iii) expresses the complete fault detectability condition [1].","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The EFDP can be formulated with the stronger requirement that the columns of R_f(lambda) do not vanish for a set of  relevant complex frequencies Omega characterizing the classes of persistent fault inputs:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EFDP with strong fault detectability:  For a given set of complex frequencies Omega,  determine a stable\tresidual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii) R_f_j(lambda_z) not = 0 forall lambda_z in Omega  j = 1 ldots m_f  textwith  R_f(lambda)  colormagenta textstable \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Condition (iii) expresses the complete strong fault detectability condition [1].","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving fault detection problems, it is important to assess the sensitivity of the residual signal to individual fault components. The assessment of  complete fault detectability can be done by checking   R_f(lambda) _infty -   0, where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" R_f(lambda) _infty - = min_j R_f_j(lambda)_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"is the mathcalH_infty --index defined in [1], as a measure of the degree of complete fault detectability. If  R_f(lambda) _infty -  = 0, then at least one fault component is not detectable in the residual signal r. The assessment of the strong complete fault detectability with respect to a set of frequencies contained in a set Omega comes down to check  R_f_j(lambda_z) neq 0, for forall lambda_z in Omega and for j = 1 ldots m_f. Alternatively, the assessment of strong complete fault detectability can be done by checking   R_f(lambda) _Omega -   0, where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" R_f(lambda) _Omega - = min_j    inf_lambda_z in Omega R_f_j(lambda_z)_2 ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"is the (modified) mathcalH_infty --index defined over the frequencies contained in Omega (see [1]). Since nonzero values of  R_f(lambda) _infty - or  R_f(lambda) _Omega - are not invariant to scaling (e.g., when replacing Q(lambda) by alpha Q(lambda)), these quantities are less appropriate to quantitatively assess the degrees of complete detectability.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The function fdhinfminus can be employed to evaluate R_f(lambda) _infty -  and  R_f(lambda) _Omega -. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A performance measure associated to a fault detection filter Q(lambda) which solves the EFDP is a scaling independent measure of the complete fault detectability called the fault sensitivity condition and is defined (over all frequencies) as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" J_1 =    R_f(lambda) _infty -  max_j R_f_j(lambda)_infty ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Similarly, scaling independent measure of the strong complete fault detectability  can be defined over the frequencies contained in the set Omega as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_1 =    R_f(lambda) _Omega -  max_j sup_lambda_z in Omega R_f_j(lambda_z)_2  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"We have that 0  J_1 leq 1 and 0  widetilde J_1 leq 1 and a value of J_1 (or of widetilde J_1) near to 1, indicates nearly equal sensitivities of residual to all fault components, and makes easier the choice of suitable thresholds for fault detection. On contrary, a small value of J_1 (or of widetilde J_1) indicates potential difficulties in detecting some components of the fault vector, due to a very low sensitivity of the residual to these fault components. In such cases, employing fault detection filters with several outputs (q  1) could be advantageous.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection filters which solve the EFDP the function efdsyn is available and for the evaluation of the  fault sensitivity condition the function fdiscond is available. ","category":"page"},{"location":"FDDbasics.html#Exact-fault-detection-and-isolation-problem-(EFDIP)","page":"Fault detection and diagnosis basics","title":"Exact fault detection and isolation problem (EFDIP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EFDIP: Given a structure matrix S, determine a stable \tresidual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)  S_R_f = S  textwith  R_f(lambda)  colormagenta textstable \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The condition (iii) expresses the S fault isolability property [1].","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The solution of the EFDIP can be addressed by solving n_b suitably formulated EFDPs. The i-th EFDP arises by reformulating the i-th EFDIP for determining the i-th  filter Q^(i)(lambda) for a structure matrix which is the i-th row of S. This can be accomplished by redefining the fault components corresponding to zero entries in the i-th row of S as additional disturbance inputs to be decoupled in the i-th residual component r^(i)(t).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving fault detection and isolation problems with a targeted structure matrix S, we obtain partitioned filters (see above) and we can define for each individual filter an associated fault sensitivity condition number. Let f^(i) be formed from the subset of faults corresponding to nonzero entries in the i-th row of S and let R_f^(i)^(i)(lambda) be formed from the corresponding columns of R_f^(i)(lambda).  To characterize the  complete fault detectability of the subset of faults corresponding to nonzero entries in the i-th row of S we can define the fault sensitivity condition number of the i-th filter as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"J_1^(i) =   big R_f^(i)^(i)(lambda) big_infty -  max_j bigR_f_j^(i)(lambda)big_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Similarly, to characterize the strong complete fault detectability of the subset of faults corresponding to nonzero entries in the i-th row of S,  we define the fault condition number of the i-th filter as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_1^(i) =   big R_f^(i)^(i)(lambda) big_Omega -  max_j sup_lambda_z in Omega bigR_f_j^(i)(lambda_z)big_2   ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection filters which solve the EFDIP the function efdisyn is available and for the evaluation of the  fault sensitivity condition the function fdiscond is available. ","category":"page"},{"location":"FDDbasics.html#Approximate-fault-detection-problem-(AFDP)","page":"Fault detection and diagnosis basics","title":"Approximate fault detection problem (AFDP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"AFDP: Determine a stable residual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii) R_f_j(lambda) not = 0 j = 1 ldots m_f  textwith  R_f(lambda)  colormagenta textstable \n  (iv)  R_w(lambda)  approx 0  textwith  R_w(lambda)  colormagenta textstable\n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The performance of a fault detection filter Q(lambda) which solves the AFDP can be characterized by the fault-to-noise gap defined as ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"J_2 = R_f(lambda) _infty -  R_w(lambda)_infty","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"By convention, J_2 = 0 if  R_f(lambda) _infty - = 0 and J_2 = infty if  R_f(lambda) _infty -  0 and  R_w(lambda) _infty = 0 (e.g., when solving exact synthesis problems without noise inputs).  A finite frequency variant of the above criterion, which allows to address strong fault detectability aspects for a given set Omega of relevant frequencies is","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_2 =  R_f(lambda) _Omega -   R_w(lambda) _infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The higher the value of J_2 (or widetilde J_2), the easier is to choose suitable thresholds to be used for fault detection purposes in the presence of noise. Therefore, the maximization of the above gaps is a valuable goal in improving the fault detection capabilities of the fault diagnosis system in the presence of exogenous noise.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The value eta = J_2 can be used to determine an estimation of the minimum size delta_fmin of detectable faults, as delta_fmin = delta_w  eta, where, for delta_w is an upper bound on the magnitude of the noise input w(t) (i.e., w  leq delta_w).  The resulting value of delta_fmin can be used to assess the practical usefulness of any solution, and the maximization of the gap J_2 is always a meaningful goal for the synthesis of fault detection filters. Note that J_2 = infty for a filter Q(lambda) solving an EFDP with w equiv 0. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection filters which solve the AFDP the function afdsyn is available and for the evaluation of the  fault sensitivity condition the function fdif2ngap is available. ","category":"page"},{"location":"FDDbasics.html#Approximate-fault-detection-and-isolation-problem-(AFDIP)","page":"Fault detection and diagnosis basics","title":"Approximate fault detection and isolation problem (AFDIP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Let S be a desired n_btimes m_f structure matrix targeted to be achieved by using a structured fault detection filter Q(lambda) with n_b row blocks (see also the formulation of the EFDIP) and let R_f(lambda) be the corresponding n_btimes m_f block-structured TFM. R_f(lambda) can be additively decomposed as R_f(lambda) = widetilde  R_f(lambda) + overline R_f(lambda), where  widetilde  R_f(lambda) and overline R_f(lambda) have the same block structure as R_f(lambda) and have their (ij)-th blocks defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde  R^(i)_f_j(lambda) = S_ijR^(i)_f_j(lambda) quad overline R^(i)_f_j(lambda) = (1-S_ij)R^(i)_f_j(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"To address the approximate fault detection and isolation problem, we will target to enforce for the part widetilde R_f(lambda) of R_f(lambda) the desired structure matrix S, while the part overline R_f(lambda) must (ideally) be negligible.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"AFDIP: Given a structure matrix S, determine a stable residual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)   S_widetilde R_f = S  overline R_f(lambda) approx 0 textwith  R_f(lambda)  colormagenta textstable\n  \n  (iv)  R_w(lambda)  approx 0  textwith  R_w(lambda)  colormagenta textstable\n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving an AFDIP, it is usually attempted to fulfil the stronger requirement that overline R_f(lambda) =  0 (which is equivalent to require S_R_f = S). If this is not feasible, then the above problem is solved.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For a partitioned filter corresponding to a targeted structure matrix S, we can define for the i-th filter component the associated value of the fault-to-noise gap, which  characterizes the noise attenuation properties of the i-th filter. Let f^(i) be formed from the subset of faults corresponding to nonzero entries in the i-th row of S and  let bar f^(i) be formed from the complementary subset of faults corresponding to zero entries in the i-th row of S. If R_f^(i)^(i)(lambda) and R_bar f^(i)^(i)(lambda)  are formed from the columns of R_f^(i)(lambda) corresponding to f^(i) and bar f^(i), respectively, then the fault-to-noise gap of the i-th filter can be defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" J_2^(i) =   big R_f^(i)^(i)(lambda) big_infty -  bigbig R_bar f^(i)^(i)(lambda)   R_w^(i)(lambda)bigbig_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For a similar characterization of the strong complete fault detectability of the subset of faults corresponding to nonzero entries in the i-th row of S,  we have","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" widetilde J_2^(i) =   big R_f^(i)^(i)(lambda) big_Omega -  bigbig R_bar f^(i)^(i)(lambda)   R_w^(i)(lambda)bigbig_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection and isolation filters which solve the AFDIP the function afdisyn is available and for the evaluation of the  fault sensitivity condition the function fdif2ngap is available. ","category":"page"},{"location":"FDDbasics.html#Exact-model-matching-problem-(EMMP)","page":"Fault detection and diagnosis basics","title":"Exact model-matching problem (EMMP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Let M_r(lambda) be a given qtimes m_f TFM of a stable reference model  specifying the desired input-output behavior from the faults to residuals as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = M_r(lambda) mathbff(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Together with the decoupling conditions R_u(lambda) = 0 and R_d(lambda) = 0, the determination of  Q(lambda) involves the solution of a linear matrix equation with rational function coefficients. However, a particular choice of M_r(lambda) may lead to a solution Q(lambda) which is not proper or is unstable or has both these undesirable properties. Therefore, besides determining Q(lambda),  the determination of a suitable updating factor M(lambda) of M_r(lambda) is necessary to ensure the stability of the solution Q(lambda) for R_f(lambda) = M(lambda) M_r(lambda) (and also of R_w(lambda)). This leads to the following formulation of the EMMP:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EMMP: Determine a stable residual generator Q(lambda) and a  stable, diagonal, and invertible M(lambda) such that ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)  R_f(lambda) = M(lambda)M_r(lambda) \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A typical choice for M_r(lambda) is an m_f times m_f  diagonal and invertible TFM, which ensures that each residual r_i(t) is influenced only by the fault f_i(t). This would allow the isolation of arbitrary combinations of up to m_f simultaneous faults.  The choice M_r(lambda) = I_m_f targets the solution of an  exact fault estimation problem (EFEP).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection and isolation filters which solve the EMMP the function emmsyn is available. This function can also address the solution of the EMMP with more general reference models (e.g., having components from the control inputs and/or disturbance inputs). ","category":"page"},{"location":"FDDbasics.html#Approximate-model-matching-problem-(AMMP}","page":"Fault detection and diagnosis basics","title":"Approximate model-matching problem (AMMP}","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Let M_r(lambda) be a given qtimes m_f TFM of a stable reference model  specifying the desired input-output behavior from the faults to residuals as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = M_r(lambda) mathbff(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"AMMP: Determine a stable residual generator Q(lambda) and a  stable, diagonal, and invertible M(lambda) such that ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)  R_f(lambda) approx M(lambda)M_r(lambda) \n  (iv)  R_w(lambda)  approx 0  textwith  R_w(lambda)  colormagenta textstable\n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A criterion suitable to characterize the solution of approximate model-matching based syntheses is the  residual error norm","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"J_3 = big R(lambda)- M_r(lambda)big_infty2 ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where R(lambda) = R_f(lambda) and M_r(lambda) the reference model (possibly updated). For more generality, this criterion can be defined with  R(lambda) =  R_u(lambda) R_d(lambda) R_f(lambda) R_w(lambda) , the resulting internal form, and M_r(lambda) the desired reference model M_r(lambda) =  M_ru(lambda) M_rd(lambda) M_rf(lambda) M_rw(lambda). When applied to the results computed by other synthesis approaches (e.g., to solve the AFDP or AFDIP), this criterion can be formulated as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_3 = big R_w(lambda)big_infty2 ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"which corresponds to assume that M(lambda) = I and M_r(lambda) =  R_u(lambda) R_d(lambda) R_f(lambda) 0  (i.e., a perfect matching of control, disturbance and fault channels is always achieved).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection and isolation filters which solve the AMMP the function ammsyn is available. This function can also address the solution of the AMMP with more general reference models (e.g., having components from the control inputs, disturbance inputs and noise inputs). For the evaluation of the  model-matching performace the function fdimmperf is available. ","category":"page"},{"location":"FDDbasics.html#References","page":"Fault detection and diagnosis basics","title":"References","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"FDIsynthesis.html#Solving-fault-detection-and-isolation-problems","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"","category":"section"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn  Exact synthesis of fault detection filters.\nefdisyn  Exact synthesis of fault detection and isolation filters.\nafdsyn  Approximate synthesis of fault detection filters.\nafdisyn  Approximate synthesis of fault detection and isolation filters.\nemmsyn  Exact model-matching based synthesis of fault detection filters.\nammsyn  Approximate model-matching based synthesis of fault detection filters.","category":"page"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn\nefdisyn\nafdsyn\nafdisyn\nemmsyn\nammsyn","category":"page"},{"location":"FDIsynthesis.html#FaultDetectionTools.efdsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.efdsyn","text":"efdsyn(sysf::FDIModel; rdim, nullspace = true, simple = false, minimal = true, \n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection problem (EFDP) for a given synthesis model sysf with additive faults. The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EFDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.S, and info.HDesign,  contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter in internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the EFDP ensures that Ru(λ) = 0, Rd(λ) = 0, and Rf(λ) has all its columns nonzero.  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe resulting filters Q.sys and R.sys have observable state-space realizations (AQ,BQ,CQ,DQ) and (AQ,BR,CQ,DR), respectively, and thus share the observable pairs (AQ,CQ). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false a full order synthesis is performed.  \n\nIf HDesign = H, a full row rank design matrix H is used to build rdim = q  linear combinations of the left nullspace basis vectors (default: HDesign = missing)\n\nrdim = q specifies the desired number q of residual outputs for Q and R.  The default value of q is chosen as follows: if HDesign = missing, then   q = 1, if minimal = true, or q is the number of the nullspace basis  vectors used for the initial synthesis, if minimal = false;  if HDesign = H specifies a full row rank design matrix H,  then q is the row dimension of H. \n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used for the synthesis of the fault detection filter. If nullspace = false, a full-order observer based nullspace basis is used.  This option can be only used for a proper system without disturbance inputs. \n\nIf simple = true, a simple proper nullspace basis is emplyed for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then no simple basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, S, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.S is the binary structure matrix corresponding to the computed left nullspace basis;\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter.\n\nMethod: The Procedure EFD from [1] is implemented to solve  the exact fault detection problem. For more details on  the least order synthesis of fault detection filters see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.2.\n\n[2] A. Varga, On computing least order fault detectors using rational nullspace bases.  IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n\n\n\n\nefdsyn(sysf::FDIModel, S; rdim, nullspace = true, simple = false, minimal = true, \n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection isolation problem (EFDIP) for a given synthesis model sysf with additive faults and a given binary structure vector S.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EFDIP, and its internal form, respectively, and are determined such that R.sys[:,faults] has its j-th column nonzero if S[j] = 1 and the j-th column is zero if S[j] = 0.  For the description of the keyword parameters see the function efdsyn. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.efdisyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.efdisyn","text":"efdisyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, separate = false,\n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection and isolation problem (EFDIP) for a given synthesis model sysf with additive faults and a given binary structure matrix SFDI with nb rows (specifications).  The computed stable and proper filter objects Q and R contain the  fault detection and isolation filter, representing the solution of the EFDIP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs and info.HDesign,  contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection and isolation filter object Q, contains in Q.sys the resulting bank of nb filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i, the i-th component (scalar or vector)  of the overall residual vector r := [r_1; r_2; ...; r_nb].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u   ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the i-th residual component.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter in internal form object R, contains R.sys, the resulting bank of nb  internal form of the filters.   The i-th filter R.sys[i] is in a standard state-space form, which generates the residual signal r_i, and corresponds to the  input-output form\n\n   r_i = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | := |Qyi(λ) Qui(λ)]*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                             |   I     0     0     0     0   |\n\nThe solution of the EFDIP ensures that for the i-th filter, Rui(λ) = 0, Rdi(λ) = 0, and  Rfi(λ) has its j-th column nonzero if the (i,j)-th element of SFDI is nonzero.  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe resulting component filters Q.sys[i] and R.sys[i] have observable state-space realizations (AQi,BQi,CQi,DQi) and (AQi,BRi,CQi,DRi), respectively, and thus share the observable pairs (AQi,CQi). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter synthesis is performed to determine each of the component filters Q.sys[i] and R.sys[i] for i = 1, ...,nb, while  with minimal = false full order synthesis is performed.  \n\nIf HDesign = H, then H is an nb-dimensional array of full row rank or empty design matrices H = [H_1, ..., H_nb], where H_i is the design matrix employed for the synthesis of the i-th component filter (default: HDesign = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filters Q.sys[i] and R.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. The default value of q[i] is chosen as follows: if HDesign = missing or H_i is empty then   q[i] = 1, if minimal = true, or q[i] is the number of the nullspace basis  vectors used for the synthesis of Q.sys[i] and R.sys[i], if minimal = false;  if  H_i specifies a full row rank design matrix, then q[i] is the row dimension of H_i. \n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used at the  initial reduction step, if separate = false,  or at all synthesis steps, if separate = true. If nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step, if separate = false, or at all synthesis steps, if separate = true. This option can  only be used for a proper system without disturbance inputs. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  The orders of the basis vectors employed for the synthesis of i-th filter are provided in info.deg[i].  If simple = false (default), then no simple bases are computed. \n\nIf separate = false (default), a two-step synthesis procedure is employed,  where a minimal proper nullspace basis is used at the  initial reduction step.  If separate = true, the filter components are separately determined by solving appropriately formulated fault detection problems. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, HDesign), where:\n\ninfo.tcond is an nb-dimensional vector, whose i-th component is the maximum of the condition numbers of the employed  non-orthogonal transformation matrices employed for the synthesis of the i-th filter component;  a warning is issued if any info.tcond[i] >= tcmax;\n\ninfo.degs is an nb-dimensional vector, whose i-th component is an integer vector  containing the degrees of the basis vectors of the employed simple nullspace basis for the synthesis of the i-th filter component, if simple = true,  and the degrees of the basis vectors of an equivalent polynomial nullspace basis, ifsimple = false`;\n\ninfo.HDesign is an nb-dimensional vector, whose i-th component is  is the design matrix H_i employed for the synthesis of  the i-th fault detection filter.\n\nMethod: The Procedure EFDI from [1] is implemented to solve  the exact fault detection and isolation problem.  This procedure relies on the nullspace-based synthesis method proposed in [2]. For more  details on the least order synthesis of fault detection filters see [3].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.4.\n\n[2] A. Varga,  On designing least order residual generators for fault detection      and isolation. 16th International Conference on Control Systems and       Computer Science, Bucharest, Romania, 2007.\n\n[3] A. Varga, On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.afdsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.afdsyn","text":"afdsyn(sysf::FDIModel; rdim, nullspace = true, simple = false, minimal = true, exact = false, \n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                          -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection problem (AFDP) for a given synthesis model sysf with additive faults. The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the AFDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.degs2,  info.S, info.S2, info.HDesign, info.HDesign2, info.freq and info.gap contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u  ,\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter in internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the AFDP ensures that Ru(λ) = 0, Rd(λ) = 0, Rf(λ) has all its columns nonzero and the H∞-norm of Rw(λ) satisfies ||Rw(λ)||∞ < γ, where the bound γ is  specified via the keyword argument gamma. The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe transfer function matrices Q(λ) = [ Qy(λ) Qu(λ) ] and R(λ) = [ Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) ]  of the resulting filters Q.sys and R.sys, respectively, have, in general, the partitioned forms\n\n Q(λ) = [ Q1(λ) ] ,   R(λ) = [ R1(λ) ] ,                      (1)\n        [ Q2(λ) ]            [ R2(λ) ]\n\nwhere the filters Q1(λ) and R1(λ) with q1 outputs are the solution of an  AFDP, while the filters Q2(λ) and R2(λ) with q2 outputs are the solution of an   exact fault detection problem formulated for a reduced system obtained   by decoupling the control and disturbance inputs from the residuals (see [4]).   The overall resulting filters Q.sys and R.sys have observable state-space  realizations (AQ,BQ,CQ,DQ) and (AQ,BR,CQ,DR), respectively, and thus   share the observable pairs (AQ,CQ). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false a full order synthesis is performed.  \n\nIf exact = true, an exact synthesis (without optimization) is performed, while  with exact = false (default), an approximate synthesis is performed.  \n\nIf HDesign = H1, a design matrix H1 of full row rank q1 is used to build q1  linear combinations of the left nullspace basis vectors of  G1(λ) := [ Gu(λ) Gd(λ); I 0]. H1 is used in the synthesis of the components  Q1(λ) and R1(λ) in (1) (default: HDesign = missing).\n\nIf HDesign2 = H2, a design matrix H2 of full row rank q2 is used to build q2  linear combinations of the left nullspace basis vectors of  G2(λ) := [ Gu(λ) Gd(λ) Gw(λ); I 0 0]. H2 is used in the synthesis of the components  Q2(λ) and R2(λ) in (1) (default: HDesign2 = missing)\n\nrdim = q specifies the desired number q of residual outputs for Q and R.  If rdim = missing, the default value of q is chosen as q = q1 + q2, where  the default values of q1 and q2 are chosen taking into account the rank rw  of Rw(λ) in the reduced system (see [4]), as follows:  if HDesign = missing, then   q1 = min(1,rw), if minimal = true, or q1 = rw, if minimal = false;  if HDesign = H, then q1 is the row dimension of the design matrix H2. if HDesign2 = missing, then   q2 = 1-min(1,rw), if minimal = true, or q2 = nvec-rw, if minimal = false, where nvec is the number of the nullspace basis  vectors used for the initial synthesis (see [1]);  if HDesign2 = H2, then q2 is the row dimension of the design matrix H2.\n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used for  the initial synthesis of the fault detection filter.  If nullspace = false, a full-order observer based nullspace basis is used.  This option can be only used for a proper system without disturbance inputs. \n\nIf simple = true, a simple proper nullspace basis is emplyed for synthesis.  The orders of the basis vectors employed for the synthesis are provided in info.deg and info.deg2 (see below).  If simple = false (default), then no simple basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\nscale2 = σ2 specifies the scaling factor σ2 to be employed for the components  Q2(λ) and R2(λ) in (1), i.e.,  use  σ2*Q2(λ) and σ2*R2(λ) instead of Q2(λ) and R2(λ).  (default: σ2 is chosen to ensure the minimum gap provided by Q1(λ)) \n\nfreq = val specifies the values of a test frequency to be employed to check the  full row rank admissibility condition (default: randomly generated in the interval (0,1)).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax of  the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\ngamma = γ specifies the allowed upper bound for ∥Rw(λ)∥∞ (default: γ = 1).\n\nepsreg = ϵ specifies the value of the regularization parameter ϵ (default: ϵ = 0.1)\n\nsdegzer = δ specifies the prescribed stability degree δ for zeros shifting    (default: δ = −0.05 for a continuous-time system sysf.sys and     δ = 0.95 for a discrete-time system sysf.sys).\n\nnonstd = job specifies the option to handle nonstandard optimization problems, as follows:\n\n  job = 1 – use the quasi-co-outer–co-inner factorization (default);\n  job = 2 – use the modified co-outer–co-inner factorization with the\n            regularization parameter `ϵ`;\n  job = 3 – use the Wiener-Hopf type co-outer–co-inner factorization;\n  job = 4 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            zero shifting of the non-minimum phase factor using the\n            stabilization parameter `δ`;\n  job = 5 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            the regularization of the non-minimum phase factor using the\n            regularization parameter `ϵ`.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, degs2, S, S2, HDesign, HDesign2, freq, gap), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G1(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G1(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal.  This information has been used in the case  minimal = true to determine the least order of components Q1(λ) and R1(λ) in (1).\n\ninfo.degs2 is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G2(λ) := [ Gu(λ) Gd(λ) Gw(λ); I 0 0] (also the left Kronecker indices of G2(λ)), if the  state-space realization of [Gu(λ) Gd(λ) Gw(λ)] is minimal.  This information has been used in the case  minimal = true to determine the least order of components Q2(λ) and R2(λ) in (1).\n\ninfo.S is the binary structure matrix of the reduced system  corresponding to the computed left nullspace basis of G1(λ) := [ Gu(λ) Gd(λ); I 0];\n\ninfo.S2 is the binary structure matrix of the reduced system  corresponding to the computed left nullspace basis of G2(λ) := [ Gu(λ) Gd(λ)  Gw(λ); I 0 0];\n\ninfo.HDesign is the design matrix H1 employed for the synthesis of     the components Q1(λ) and R1(λ) in (1) of the fault detection filter;\n\ninfo.HDesign2 is the design matrix H2 employed for the synthesis of  the components Q2(λ) and R2(λ) in (1) of the fault detection filter;\n\ninfo.freq is the frequency value employed to check the full  row rank admissibility condition;\n\ninfo.gap is the achieved gap ∥Rf(λ)∥∞−/∥Rw(λ)∥∞, where the H−minus index is computed over the whole frequency range, if FDfreq = missing, or over the frequency values contained in freq if FDfreq = freq.\n\nMethod: An extension of the Procedure AFD from [1] is implemented to solve  the approximate fault detection problem (see also [2] and Remark 5.10 of [1]).  The employed regularization approach, based on the modified co-outer-co-inner  factorization, is discussed in [3], see also Remark 5.8 of [1].  For the details of the implemented method, see the documentation of the afdsyn function in [4]. \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.3.\n\n[2] A. Varga, General computational approach for optimal fault detection.                Proc. IFAC Symposium SAFEPROCESS, Barcelona, Spain, pp. 107–112, 2009.\n\n[3] K. Glover and A. Varga, On solving non-standard H-/H_2/inf fault detection problems.                Proc. IEEE CDC, Orlando, FL, USA, pp. 891–896, 2011.\n\n[4] A. Varga, Fault Detection and Isolation Tools (FDITOOLS) User's Guide,                arXiv:1703.08480. \n\n\n\n\n\nafdsyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, exact = false, \n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true)  \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection and isolation problem (AFDIP) for a given synthesis model sysf with additive faults and a given binary structure vector SFDI.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the AFDIP, and its internal form, respectively,  and are determined such that the transfer function matrix of  R.sys[:,faults] has its j-th column nonzero if SFDI[j] = 1.  If the solution of a strong AFDIP is feasible, then the j-th column is zero if SFDI[j] = 0.  If only a the solution of a  weak AFDIP is feasible, then the j-th column may be nonzero if SFDI[j] = 0.  For the description of the keyword parameters see the function afdsyn. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.afdisyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.afdisyn","text":"afdisyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, separate = false,\n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection and isolation problem (AFDIP) for a given synthesis model sysf with additive faults and a given binary structure matrix SFDI with nb rows (specifications).  The computed stable and proper filter objects Q and R contain the  fault detection and isolation filter, representing the solution of the AFDIP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.degs2, info.HDesign,  info.HDesign2 andinfo.gap contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection and isolation filter object Q, contains in Q.sys the resulting bank of nb filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i, the i-th component (scalar or vector)  of the overall residual vector r := [r_1; r_2; ...; r_nb].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u   ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the i-th residual component.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter in internal form object R, contains R.sys, the resulting bank of nb  internal form of the filters.   The i-th filter R.sys[i] is in a standard state-space form, which generates the residual signal r_i, and corresponds to the  input-output form\n\n   r_i = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | := |Qyi(λ) Qui(λ)]*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                             |   I     0     0     0     0   |\n\nThe solution of the AFDIP ensures that for the i-th filter, Rui(λ) = 0, Rdi(λ) = 0,  Rfi(λ) has its j-th column nonzero if the (i,j)-th element of SFDI is nonzero,  and the H∞-norm of Rwi(λ) satisfies ||Rwi(λ)||∞ < γ, where the bound γ is  specified via the keyword argument gamma. The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe transfer function matrices Qi(λ) := [ Qyi(λ) Qui(λ) ] and Ri(λ) := [ Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) ]  of the i-th components of the resulting filters Q.sys and R.sys, respectively, have, in general, the partitioned forms\n\n Qi(λ) = [ Q1i(λ) ] ,   Ri(λ) = [ R1i(λ) ] ,                      (1)\n         [ Q2i(λ) ]             [ R2i(λ) ]\n\nwhere the filters Q1i(λ) and R1i(λ) with q1i outputs are the solution of an  AFDP, while the filters Q2i(λ) and R2i(λ) with q2i outputs are the solution of an   exact fault detection problem formulated for a reduced system obtained   by decoupling the control and disturbance inputs from the residuals (see [4]).   The overall resulting component filters Q.sys[i] and R.sys[i] have observable state-space  realizations (AQi,BQi,CQi,DQi) and (AQi,BRi,CQi,DRi), respectively, and thus   share the observable pairs (AQi,CQi). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter synthesis is performed to determine each of the component filters Q.sys[i] and R.sys[i] for i = 1, ...,nb, while  with minimal = false full order synthesis is performed.  \n\nIf exact = true, an exact synthesis (without optimization) is performed, while  with exact = false (default), an approximate synthesis is performed.  \n\nIf HDesign = H1, then H1 is an nb-dimensional array of full row rank or empty design matrices, where H1[i] is the design matrix employed for the synthesis   of the components Q1i(λ) and R1i(λ) in (1) of the i-th filter  (default: HDesign = missing)\n\nIf HDesign2 = H2, then H2 is an nb-dimensional array of full row rank or empty design matrices,  where H2[i] is the design matrix employed for the synthesis  of the components Q2i(λ) and R2i(λ) in (1) of the i-th filter   (default: HDesign2 = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filters Q.sys[i] and R.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. If rdim = missing, the default value of q[i] is chosen as q[i] = q1i + q2i, where  the default values of q1i and q2i are chosen taking into account the rank rwi  of Rwi(λ) in the reduced system (see [2]),  as follows:  if HDesign = missing, then   q1i = min(1,rwi), if minimal = true, or q1i = rwi, if minimal = false;  if HDesign = H1, then q1i is the row dimension of the nonemty design matrix H1[i], or if H1[i] is empty, the above choice for HDesign = missing is employed; if HDesign2 = missing, then   q2i = 1-min(1,rwi), if minimal = true, or q2i is set to its maximum achievable value,  if minimal = false (see [1]);  if HDesign2 = H2, then q2i is the row dimension of the nonemty design matrix H2[i], or  if H2[i] is empty, the above choice for HDesign2 = missing is employed.\n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used at the  initial reduction step, if separate = false,  or at all synthesis steps, if separate = true. If nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step, if separate = false, or at all synthesis steps, if separate = true. This option can  only be used for a proper system without disturbance inputs. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  If simple = false (default), then no simple bases are computed. \n\nIf separate = false (default), a two-step synthesis procedure is employed,  where a minimal proper nullspace basis is used at the  initial reduction step.  If separate = true, the filter components are separately determined by solving appropriately formulated fault detection problems. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nscale2 = σ2 specifies the vector of scaling factors σ2 to be employed for the components  Q2i(λ) and R2i(λ) in (1), i.e.,  use  σ2[i]*Q2i(λ) and σ2[i]*R2i(λ) instead of Q2i(λ) and R2i(λ).  (default: For scale2 = missing, each σ2[i] is chosen to ensure the minimum gap provided by Q1i(λ)) \n\ngamma = γ specifies the allowed upper bound for the resulting ∥Rwi(λ)∥∞ (default: γ = 1).\n\nepsreg = ϵ specifies the value of the regularization parameter ϵ used in afdsyn (default: ϵ = 0.1)\n\nsdegzer = δ specifies the prescribed stability degree δ for zeros shifting    (default: δ = −0.05 for a continuous-time system sysf.sys and     δ = 0.95 for a discrete-time system sysf.sys).\n\nnonstd = job specifies the option to handle nonstandard optimization problems in afdsyn, as follows:\n\n  job = 1 – use the quasi-co-outer–co-inner factorization (default);\n  job = 2 – use the modified co-outer–co-inner factorization with the\n            regularization parameter `ϵ`;\n  job = 3 – use the Wiener-Hopf type co-outer–co-inner factorization;\n  job = 4 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            zero shifting of the non-minimum phase factor using the\n            stabilization parameter `δ`;\n  job = 5 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            the regularization of the non-minimum phase factor using the\n            regularization parameter `ϵ`.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, HDesign, HDesign2, freq, gap), where:\n\ninfo.tcond is an nb-dimensional vector, whose i-th component is the maximum of the condition numbers of the employed  non-orthogonal transformation matrices employed for the synthesis of the i-th filter component;  a warning is issued if any info.tcond[i] >= tcmax;\n\ninfo.HDesign = H1 is an nb-dimensional vector of design matrices,  whose i-th component H1[i] is the design matrix to be employed for the synthesis  of the components Q1i(λ) and R1i(λ) in (1) of  the i-th fault detection filter.\n\ninfo.HDesign2 = H2 is an nb-dimensional vector of design matrices,  whose i-th component H2[i] is the design matrix to be employed for the synthesis  of the components Q2i(λ) and R2i(λ) in (1) of   the i-th fault detection filter.\n\ninfo.freq is the frequency value employed to check the full  row rank admissibility condition.\n\ninfo.gap is an nb-dimensional vector, whose i-th component is the  achieved gap for the synthesis of the i-th filter component.\n\nMethod: The Procedure AFDI from [1] is implemented to solve  the approximate fault detection and isolation problem. For implementation details, see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.5.\n\n[2] A. Varga, Fault Detection and Isolation Tools (FDITOOLS) User's Guide,                arXiv:1703.08480. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.emmsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.emmsyn","text":"emmsyn(sysf::FDIModel, sysr::FDFilterIF; nullspace = true, simple = false, minimal = true, regmin = true, normalize = \"gain\", \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact model-matching problem (EMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given stable reference filter sysr::FDFilterIF.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EMMP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq  and info.HDesign, contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filter sysr.sys is in a standard or descriptor state-space form sysr.sys = (Ar-λEr,Br,Cr,Dr), which corresponds to the input-output form  \n\n   yr = Mru(λ)*u + Mrd(λ)*d + Mrf(λ)*f + Mrw(λ)*w + Mra(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yr, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mru(λ), Mrd(λ), Mrf(λ), Mrw(λ), and Mra(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrix is considered null. \n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the standard EMMP is computed if sysr.noise and sysr.aux are void and ensures that Ru(λ) = M(λ)*Mru(λ), Rd(λ) = M(λ)*Mrd(λ) and Rf(λ) = M(λ)*Mrf(λ), where M(λ) is  the transfer function matrix of a stable, diagonal and invertible updating filter returned in info.M.  This filter is determined to guarantee the stability of resulting filters Q and R.   If sysr.noise and sysr.aux are not both void, then  the extended EMMP is solved which additionally ensures Rw(λ) = M(λ)*Mrw(λ) and Ra(λ) = M(λ)*Mra(λ).  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively.\n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false no least order synthesis is performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case when sysr.controls and sysr.disturbances are void with the selection of  a least order left annihilator Nl(λ) such that  Nl(λ)*[Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing  Nl(λ) a minimal left nullspace basis of G(λ) = [Gu(λ) Gd(λ); I 0 ].  \n\nIf HDesign = H is a full row rank design matrix, then H*Nl(λ) is used  instead Nl(λ) (default: HDesign = missing).\n\nAn initial reduction step is performed using the nullspace-based approach (see [1])  if sysr.controls, sysr.disturbances, sysr.noise and sysr.aux are void and minimal = false. In this case,   if nullspace = true (default), a minimal proper nullspace basis is used at the initial reduction step, while, if nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step. This later option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if any of sysr.controls, sysr.disturbances, sysr.noise or sysr.aux is non-void or if minimal = true \n\nIf simple = true, a simple proper nullspace basis Nl(λ)  is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrix M(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation (default);\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is the employed stable and invertible updating filter used to solve the EMMP,  with a diagonal transfer function matrix M(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter Q; H = missing if no design matrix was involved.\n\nMethod: The synthesis Procedures EMM and EMMS from [1] are implemented.   Procedure EMM relies on the model-matching synthesis method proposed in    [2], while Procedure EMMS uses the inversion-based method proposed in [3].    Procedure EMM is generally employed, unless a strong exact fault    detection and isolation problem (strong EFDIP) is solved, in   which case Procedure EMMS is used. \n\nThe strong EFDIP corresponds to the choice of the reference filter sysr such that   Mru(λ) = 0, Mrd(λ) = 0, Mrf(λ) is invertible, Mrw(λ) = 0 and Mra(λ) = 0.    In this case, only the indices of fault inputs sysr.faults must be specified   and the indices of the rest of inputs must be void.    The solution of a fault estimation problem can be targeted by   choosing Mrf(λ) = I and checking that the resulting info.M = I. \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, New computational approach for the design of fault       detection and isolation filters.        In M. Voicu (Ed.), \"Advances in Automatic Control\", vol. 754 of        The Kluwer International Series in Engineering and Computer Science,        Kluwer Academic Publishers, pp. 367-381, 2003.\n\n[3] A. Varga. New computational paradigms in solving fault detection        and isolation problems. Annual Reviews in Control, 37:25–42, 2013. \n\n\n\n\n\nemmsyn(sysf::FDIModel, sysr::FDIFilterIF; nullspace = true, simple = false, minimal = true, regmin = true, normalize = \"gain\", \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDIFilter, R::FDIFilterIF, info)\n\nSolve the exact model-matching problem (EMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given bank of stable reference filters sysr::FDIFilterIF.  The computed stable and proper filter objects Q and R contain the  bank of fault detection filters,  representing the component-wise solution of the EMMP, and  their internal forms, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq  and info.HDesign, contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filters packed in sysr  are in a standard or descriptor state-space form, where the i-th filter  sysr.sys[i] = (Ari-λEri,Bri,Cri,Dri) corresponds to the input-output form  \n\n   yri = Mrui(λ)*u + Mrdi(λ)*d + Mrfi(λ)*f + Mrwi(λ)*w + Mrai(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yri, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mrui(λ), Mrdi(λ), Mrfi(λ), Mrwi(λ), and Mrai(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrices are considered null. \n\nThe fault detection and isolation filter object Q, contains in its i-th  component Q.sys[i] the resulting filter  in a standard state-space form, which generates the i-th component  ri of the residual signal.  The corresponding input-output (implementation) form is\n\n        ri = Qyi(λ)*y + Qui(λ)*u\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter internal form object R,  contains in its i-th component R.sys[i], the resulting  internal form of the filter  in a standard state-space form,  which generates the i-th component ri of residual signal , and corresponds to the  input-output form\n\n   ri = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | = |Qyi(λ) Qui(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                            |  I     0     0     0     0    |\n\nThe component-wise solution of the standard EMMP is computed if sysr.noise and sysr.aux are void and ensures that Rui(λ) = Mi(λ)*Mrui(λ), Rdi(λ) = Mi(λ)*Mrdi(λ) and Rfi(λ) = Mi(λ)*Mrfi(λ), where Mi(λ) is  the transfer function matrix of a stable, diagonal and invertible updating filter returned in the i-th component of the vector info.M.  This filter is determined to guarantee the stability of the i-th components of resulting filters Q and R.   If sysr.noise and sysr.aux are not both void, then  the extended EMMP is component-wise solved which additionally ensures Rwi(λ) = Mi(λ)*Mrwi(λ) and Rai(λ) = Mi(λ)*Mrai(λ).  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively.\n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter syntheses are performed, while  with minimal = false no least order synthesis are performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case when sysr.controls and sysr.disturbances are void with the selection of a least order left annihilator Nl(λ) such that  Nl(λ)*[Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing  Nl(λ) a minimal left nullspace basis of G(λ) = [Gu(λ) Gd(λ); I 0 ].  \n\nIf HDesign = H is a vector of full row rank design matrices,  then H[i]*Nl(λ) is used  instead Nl(λ) for the synthesis of the i-th filter (default: HDesign = missing).\n\nAn initial reduction step is performed using the nullspace-based approach (see [1])  if sysr.controls, sysr.disturbances, sysr.noise and sysr.aux are void and minimal = false. In this case,   if nullspace = true (default), a minimal proper nullspace basis is used at the initial reduction step, while, if nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step. This later option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if any of sysr.controls, sysr.disturbances, sysr.noise or sysr.aux is non-void or if minimal = true \n\nIf simple = true, a simple proper nullspace basis Nl(λ)  is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrices Mi(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation (default);\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is a vector of descriptor systems, whose i-th system info.M[i]  contains the employed stable and invertible updating filter used to solve  the i-th EMMP, with a diagonal transfer function matrix Mi(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is a vector of design matrices H, where H[i] is the design matrix  employed for the synthesis of the i-th component of the fault detection filter Q;  H[i] is an empty matrix if no design matrix was involved.\n\nMethod: The synthesis Procedures EMM and EMMS from [1] are used  to determine the component filters.   Procedure EMM relies on the model-matching synthesis method proposed in    [2], while Procedure EMMS uses the inversion-based method proposed in [3].    Procedure EMM is generally employed, unless a strong exact fault    detection and isolation problem (strong EFDIP) is solved, in   which case Procedure EMMS is used. \n\nThe strong EFDIP corresponds to the choice of each component of the bank of    reference filters sysr such that   Mrui(λ) = 0, Mrdi(λ) = 0, Mrfi(λ) is invertible, Mrwi(λ) = 0 and Mrai(λ) = 0.    In this case, only the indices of fault inputs sysr.faults must be specified   and the indices of the rest of inputs must be void.    The solution of a fault estimation problem can be targeted by   choosing Mrfi(λ) = ei, where ei is the i-th row of the appropriate identity matrix,  and checking that the resulting info.M = 1. \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, New computational approach for the design of fault       detection and isolation filters.        In M. Voicu (Ed.), \"Advances in Automatic Control\", vol. 754 of        The Kluwer International Series in Engineering and Computer Science,        Kluwer Academic Publishers, pp. 367-381, 2003.\n\n[3] A. Varga. New computational paradigms in solving fault detection        and isolation problems. Annual Reviews in Control, 37:25–42, 2013. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.ammsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.ammsyn","text":"ammsyn(sysf::FDIModel, sysr::FDFilterIF; nullspace = true, simple = false, mindeg = false, \n                       regmin = true, normalize = \"infnorm\", H2syn = false, reltol = 1.e-4, \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate model-matching problem (AMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given stable reference filter sysr::FDFilterIF.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing a solution of the AMMP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq,  info.HDesign, info.nonstandard, info.gammaopt0, info.gammaopt and info.gammasub,   contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filter sysr.sys is in a standard or descriptor state-space form sysr.sys = (Ar-λEr,Br,Cr,Dr), which corresponds to the input-output form  \n\n   yr = Mru(λ)*u + Mrd(λ)*d + Mrf(λ)*f + Mrw(λ)*w + Mra(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yr, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mru(λ), Mrd(λ), Mrf(λ), Mrw(λ), and Mra(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrix is considered null. \n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nLet define \n\n  Ge(λ) = | Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |,  Mr(λ) = | Mru(λ) Mrd(λ) Mrf(λ) Mrw(λ) Mra(λ) | . \n          |  I     0     0     0     0    |\n\nIn the standard case, Ge(λ) has no zeros on the boundary of the  stability domain, and the resulting stable filter Q(λ) := |Qy(λ) Qu(λ)| is  Q(λ) = Q0(λ), where Q0(λ) is the optimal solution of the H∞- or H2-norm error minimization problem\n\ngammaopt0 = ||Q0(λ)*Ge(λ)-M(λ)*Mr(λ)|| = min,         (1)\n\nwhere M(λ) = M0(λ) is an updating factor chosen as follows: M0(λ) = I in the case of emplyoing the  H∞ norm, while in the case of employing the H2 norm, M0(λ) = I for a discrete-time system or, for a continuous-time system,  M0(λ) is determined a stable, diagonal, and invertible transfer function  matrix, which ensures the existence of a finite H2-norm.\n\nIn the non-standard case, Ge(λ)  has zeros on the boundary of the  stability domain, and the resulting optimal filter Q0(λ), which solves  the H∞- or H2-norm error minimization problem (1) is a possibly  unstable or improper. A second updating factor M1(λ) is determined, with    the same properties as M0(λ), which ensures that the computed stable and   proper filter Q(λ) := M1(λ)*Q0(λ) represents a suboptimal solution of an  updated H∞- or H2-norm error minimization problem, for which the    achieved suboptimal model-matching performance is\n\ngammasub = ||Q(λ)*Ge(λ)-M(λ)*Mr(λ)|| ,            (2)\n\nwhere M(λ) := M1(λ)*M0(λ). The optimal solution Qt(λ) of the  updated H∞- or H2-norm error minimization problem \n\ngammaopt = ||Qt(λ)*Ge(λ)-M(λ)*Mr(λ)|| = min ,     (3)\n\nis still possibly unstable or improper. The values of gammaopt0, gammaopt and gammasub are returned in info.gammaopt0, info.gammaopt and info.gammasub, respectively.\n\nThe fault detection filter internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = Q(λ)*Ge(λ).\n\nThe indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively. The state-space realization of the resulting M(λ) is returned in info.M.\n\nVarious user options can be specified via keyword arguments as follows:\n\nIf H2syn = false (default), a H∞-norm based synthesis is performed, while  if H2syn = true, a H2-norm based synthesis is performed. \n\nreltol = tol specifies the relative tolerance tol for the desired  accuracy of γ-iteration (default:  tol = 1.e-4).\n\nIf mindeg = true, a least order filter synthesis is performed, if possible, while  with minimal = false (default) no least order synthesis is performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case  when sysr.controls and/or sysr.disturbances are void with the selection of  a least order left annihilator Nl(λ) of G(λ) = [Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing a left annihilator Nl(λ) as a minimal left nullspace basis of G(λ).  \n\nIf HDesign = H is a full row rank design matrix, then H*Nl(λ) is used as left annihilator instead Nl(λ) (default: HDesign = missing).\n\nIf nullspace = true (default) and sysr.controls and/or sysr.disturbances are void,  a minimal proper nullspace basis is used at the initial reduction step. If nullspace = false and sysr.controls and/or sysr.disturbances are void,  a full-order observer based nullspace basis is used at the  initial reduction step. This option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if both sysr.controls and sysr.disturbances are non-void. \n\nIf simple = true, a simple proper nullspace basis   is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrix M(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation;\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms (default).\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign, gammaopt0, gammaopt, gammasub, nonstandard), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is the employed stable and invertible updating filter used to solve the AMMP,  with a stable, diagonal and invertible transfer function matrix M(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter Q; H = missing if no design matrix was involved;\n\ninfo.gammaopt0 is the optimal performance gammaopt0 for the original problem (1); \n\ninfo.gammaopt is the optimal performance gammaopt for the updated problem (3); \n\ninfo.gammasub is the suboptimal performance gammasub in (2); \n\ninfo.nonstandard is set to true for a non-standard problem     (i.e., Ge(λ) has zeros on the boundary of the stability domain), and set to     false for a standard problem        (i.e., Ge(λ) has no zeros on the boundary of the stability domain). \n\nMethod: The synthesis Procedure AMMS from [1] is implemented. The  Procedure AMMS relies on the approximate model-matching synthesis method  proposed in [2]. For more details on computational aspects see [3].  \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, Integrated computational algorithm for solving      H_inf-optimal FDI problems. In Proc. of the IFAC World Congress,      Milano, Italy, pp. 10187–10192, 2011.\n\n[3] A. Varga. Descriptor system techniques in solving H_2/H-Inf-optimal     fault detection and isolation problems\". In L. T. Biegler,       S. L. Campbell, and V. Mehrmann (Eds.), Control and Optimization      with Differential-Algebraic Constraints, vol. 23 of Advances in      Design and Control, pp. 105–125. SIAM, 2012. \n\n\n\n\n\nammsyn(sysf::FDIModel, sysr::FDIFilterIF; nullspace = true, simple = false, mindeg = false, \n                       regmin = true, normalize = \"infnorm\", H2syn = false, reltol = 1.e-4, \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate model-matching problem (AMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given bank of stable reference filters sysr::FDIFilterIF. The computed stable and proper filter objects Q and R contain the  bank of fault detection filters, representing the component-wise solution of the AMMP, and  their internal forms, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq,  info.HDesign, info.nonstandard, info.gammaopt0, info.gammaopt and info.gammasub,   contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filters packed in sysr  are in a standard or descriptor state-space form, where the i-th filter  sysr.sys[i] = (Ari-λEri,Bri,Cri,Dri) corresponds to the input-output form  \n\n   yri = Mrui(λ)*u + Mrdi(λ)*d + Mrfi(λ)*f + Mrwi(λ)*w + Mrai(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yri, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mrui(λ), Mrdi(λ), Mrfi(λ), Mrwi(λ), and Mrai(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrices are considered null. \n\nThe fault detection and isolation filter object Q, contains in its i-th  component Q.sys[i] the resulting filter  in a standard state-space form, which generates the i-th component  ri of the residual signal.  The corresponding input-output (implementation) form is\n\n        ri = Qyi(λ)*y + Qui(λ)*u\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nLet define \n\n  Ge(λ) = | Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |,  Mri(λ) = | Mrui(λ) Mrdi(λ) Mrfi(λ) Mrwi(λ) Mrai(λ) | . \n          |  I     0     0     0     0    |\n\nIn the standard case, Ge(λ) has no zeros on the boundary of the  stability domain, and each resulting component stable filter Qi(λ) := |Qyi(λ) Qui(λ)| is  Qi(λ) = Q0i(λ), where Q0i(λ) is the optimal solution of the H∞- or H2-norm error minimization problem\n\ngammaopt0i = ||Q0i(λ)*Ge(λ)-Mi(λ)*Mri(λ)|| = min,         (1)\n\nwhere Mi(λ) = M0i(λ) is an updating factor chosen as follows: M0i(λ) = I in the case of emplyoing the  H∞ norm, while in the case of employing the H2 norm, M0i(λ) = I for a discrete-time system or, for a continuous-time system,  M0i(λ) is determined a stable, diagonal, and invertible transfer function  matrix, which ensures the existence of a finite H2-norm.\n\nIn the non-standard case, Ge(λ)  has zeros on the boundary of the  stability domain, and each resulting optimal component filter Q0i(λ), which solves  the H∞- or H2-norm error minimization problem (1) is a possibly  unstable or improper. A second updating factor M1i(λ) is determined, with    the same properties as M0i(λ), which ensures that the computed stable and   proper filter Qi(λ) := M1i(λ)*Q0i(λ) represents a suboptimal solution of an  updated H∞- or H2-norm error minimization problem, for which the    achieved suboptimal model-matching performance is\n\ngammasubi = ||Qi(λ)*Ge(λ)-Mi(λ)*Mri(λ)|| ,            (2)\n\nwhere Mi(λ) := M1i(λ)*M0i(λ). The optimal solutions Qti(λ) of the  updated H∞- or H2-norm error minimization problem \n\ngammaopti = ||Qti(λ)*Ge(λ)-Mi(λ)*Mri(λ)|| = min ,     (3)\n\nis still possibly unstable or improper. The values of gammaopt0i, gammaopti and gammasubi are returned in the i-th components of the vectors info.gammaopt0, info.gammaopt and info.gammasub, respectively.\n\nThe fault detection and isolation filter internal form object R,  contains in its i-th component R.sys[i], the resulting  internal form of the filter  in a standard state-space form,  which generates the i-th component ri of residual signal , and corresponds to the  input-output form\n\n   ri = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | = Qi(λ)*Ge(λ).\n\nThe indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively. The state-space realization of the resulting Mi(λ) is returned in the i-th component of the vector info.M. \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf H2syn = false (default), a H∞-norm based synthesis is performed, while  if H2syn = true, a H2-norm based synthesis is performed. \n\nreltol = tol specifies the relative tolerance tol for the desired  accuracy of γ-iteration (default:  tol = 1.e-4).\n\nIf mindeg = true, least order filter syntheses are performed, if possible, while  with minimal = false (default) no least order synthesis are performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case  when sysr.controls and/or sysr.disturbances are void with the selection of  a least order left annihilator Nl(λ) of G(λ) = [Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing a left annihilator Nl(λ) as a minimal left nullspace basis of G(λ).  \n\nIf HDesign = H is a vector of full row rank design matrices,  then H[i]*Nl(λ) is used as left annihilator instead Nl(λ) for the synthesis of the i-th filter (default: HDesign = missing).\n\nIf nullspace = true (default) and sysr.controls and/or sysr.disturbances are void,  a minimal proper nullspace basis is used at the initial reduction step. If nullspace = false and sysr.controls and/or sysr.disturbances are void,  a full-order observer based nullspace basis is used at the  initial reduction step. This option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if both sysr.controls and sysr.disturbances are non-void. \n\nIf simple = true, a simple proper nullspace basis   is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrices Mi(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation;\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms (default).\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign, gammaopt0, gammaopt, gammasub, nonstandard), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is a vector of descriptor systems, whose i-th system info.M[i]  contains the employed stable and invertible updating filter used to solve  the i-th AMMP, with a diagonal transfer function matrix Mi(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is a vector of design matrices H, where H[i] is the design matrix  employed for the synthesis of the i-th component of the fault detection filter Q;  H[i] is an empty matrix if no design matrix was involved.\n\ninfo.gammaopt0 is a vector whose i-th component is the optimal performance gammaopt0i for the i-th original problem (1); \n\ninfo.gammaopt is a vector whose i-th component is the optimal performance gammaopti for the i-th updated problem (3); \n\ninfo.gammasub is a vector whose i-th component is the suboptimal performance gammasubi in (2); \n\ninfo.nonstandard is set to true for a non-standard problem     (i.e., Ge(λ) has zeros on the boundary of the stability domain), and set to     false for a standard problem        (i.e., Ge(λ) has no zeros on the boundary of the stability domain). \n\nMethod: The synthesis Procedure AMMS from [1] is used  to determine the component filters. The  Procedure AMMS relies on the approximate model-matching synthesis method  proposed in [2]. For more details on computational aspects see [3].  \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, Integrated computational algorithm for solving      H_inf-optimal FDI problems. In Proc. of the IFAC World Congress,      Milano, Italy, pp. 10187–10192, 2011.\n\n[3] A. Varga. Descriptor system techniques in solving H_2/H-Inf-optimal     fault detection and isolation problems\". In L. T. Biegler,       S. L. Campbell, and V. Mehrmann (Eds.), Control and Optimization      with Differential-Algebraic Constraints, vol. 23 of Advances in      Design and Control, pp. 105–125. SIAM, 2012. \n\n\n\n\n\n","category":"function"},{"location":"SynthesisParadigms.html#Synthesis-paradigms","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The implemented computational procedures for the synthesis of fault detection filters share several computational paradigms, which are instrumental in developing generally applicable, numerically reliable and computationally efficient synthesis methods. In what follows we shortly review these paradigms and discuss their roles in the synthesis procedures.","category":"page"},{"location":"SynthesisParadigms.html#Nullspace-based-synthesis","page":"Synthesis paradigms","title":"Nullspace-based synthesis","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"An important synthesis paradigm is the use of the nullspace method as a first synthesis step to ensure the fulfillment of the decoupling conditions  R_u(lambda) = 0 and R_d(lambda) = 0. This can be done by choosing Q(lambda) of the form","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":" Q(lambda) = overline Q_1(lambda) Q_1(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"where the factor Q_1(lambda) is a left nullspace basis of the rational matrix","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"G(lambda) = left beginarraycc G_u(lambda)  G_d(lambda)  I_m_u  0 endarrayright  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"It follows","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"R_u(lambda)  R_d(lambda) = Q(lambda)G(lambda)= 0  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The residual generator filter can be rewritten in the alternative form","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"mathbfr(lambda) = overline Q_1(lambda)Q_1(lambda)left beginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright = overline Q_1(lambda) overlinemathbfy(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"where","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"overlinemathbfy(lambda) = Q_1(lambda)leftbeginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright = overline G_f(lambda)mathbff(lambda) + overline G_w(lambda)mathbfw(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"with","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":" overline G_f(lambda)  overline G_w(lambda)  = Q_1(lambda)\nleft beginarraycc G_f(lambda)  G_w(lambda)  0  0 endarrayright ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"With this first preprocessing step, the original problems formulated for a system with control and disturbance inputs can be reformulated for the above reduced system (without control and disturbance inputs),  for which we have to determine the TFM overline Q_1(lambda) of the simpler fault detection filter. For the details of the implemented computational approach see Section 7.4 of [1]. ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For the computation of nullspace bases, functions available in the DescriptorSystems package are employed. ","category":"page"},{"location":"SynthesisParadigms.html#Using-filter-updating-techniques","page":"Synthesis paradigms","title":"Using filter updating techniques","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"In all implemented synthesis procedures, the TFM of the resulting filter Q(lambda) can be expressed in a factored form as","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"Q(lambda) = Q_K(lambda) cdots Q_2(lambda)Q_1(lambda)   ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"where Q_1(lambda) is a left nullspace basis of the above defined G(lambda), satisfying Q_1(lambda)G(lambda) = 0, and  Q_1(lambda), Q_2(lambda)Q_1(lambda), ldots, can be interpreted as partial syntheses addressing specific requirements. Since each partial synthesis may represent a valid fault detection filter, this approach can be flexibly used  for employing or combining different synthesis techniques.","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The determination of Q(lambda) in the above factored form can be formulated as a K-step synthesis procedure based on successive updating of an initial filter Q(lambda) = Q_1(lambda) and the nonzero terms of its corresponding  internal form","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"R(lambda) =  R_f(lambda)  R_w(lambda) = Q_1(lambda)left beginarraycc G_f(lambda)  G_w(lambda)   0  0 endarrayright","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"as follows: for k = 2 ldots K, determine Q_k(lambda) using the current Q(lambda) and R(lambda) and  then perform the updating as Q(lambda) leftarrow Q_k(lambda)Q(lambda) and  R(lambda) leftarrow Q_k(lambda)R(lambda). These updating operations are efficiently performed using state-space description based formulas. The main benefit of using explicit state-space based updating formulas is the possibility to ensure at each step the cancellation of a maximum number of poles and zeros between the factors. This allows to keep the final order of the filter Q(lambda) as low as possible. See Section 7.3 of [1] for a discussion of additional aspects. ","category":"page"},{"location":"SynthesisParadigms.html#Least-order-synthesis-based-on-admissibility-conditions","page":"Synthesis paradigms","title":"Least order synthesis based on admissibility conditions","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The least order synthesis of fault detection filters means to determine filters Q(lambda) with the least possible orders, to help in reducing the computational burden associated with their real-time implementations. The main tool to achieve least order synthesis is the solution of suitable minimal cover problems (see Section 7.5 of [1]). If X_1(lambda) and X_2(lambda) are rational matrices of the same column dimension,  then the left minimal cover problem is to find X(lambda) and Y(lambda) such that","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"X(lambda) = X_1(lambda) + Y(lambda) X_2(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"and the order of X(lambda)  Y(lambda)  is minimal.","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"A typical second step in many synthesis procedures is to choose Q_2(lambda) such that the product Q_2(lambda)Q(lambda) has least dynamical order and, simultaneously, a certain admissibility condition is fulfilled (usually involving the nonzero TFMs R_f(lambda) and R_w(lambda)). For example, for the solution of the AFDP, the rows of Q(lambda) = Q_1(lambda) form a left nullspace basis and the employed admissibility conditions  are","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"Q_2(lambda)R_f_j(lambda) not = 0 j = 1 ldots m_f ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"which  guarantee the detectability of all fault components, and additionally, the full row rank requirement on Q_2(lambda)R_w(lambda). The latter condition is only imposed for convenience, to simplify the subsequent computational steps. ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The determination of candidate solutions Q_2(lambda) such that Q_2(lambda)Q(lambda) has least order  can be done by solving left minimal cover problems, where X_1(lambda) and X_2(lambda) represent disjoint subsets of basis vectors, such that: Q(lambda) = leftbeginsmallmatrix X_1(lambda)  X_2(lambda) endsmallmatrixright, Q_2(lambda) =  I  Y(lambda),  and X(lambda) = Q_2(lambda)Q(lambda) and Y(lambda) represent the solution of the left cover problem. A systematic search over increasing orders of candidate solutions can be performed and the search stops when the admissibility conditions are fulfilled.","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"State-space representation based computational methods for the solution of minimum dynamic cover problems are described in Sections 7.5 and 10.4 of [1], together with explicit updating formulas of the state-space realizations of  Q(lambda) and R(lambda).","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For the solution of minimal cover problems, functions available in the DescriptorSystems package are employed. ","category":"page"},{"location":"SynthesisParadigms.html#Stabilization-via-left-coprime-factorization","page":"Synthesis paradigms","title":"Stabilization via left coprime factorization","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"A desired dynamics of the resulting final filters Q(lambda) and R(lambda) can be enforced by choosing a suitable invertible factor M(lambda), such that  M(lambda) Q(lambda)  R(lambda)  has desired poles. This can be achieved by computing a left coprime factorization","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":" Q(lambda)  R(lambda)  = M^-1(lambda)  N_Q(lambda)  N_R(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"with M(lambda) and  N_Q(lambda)  N_R(lambda)  coprime and having arbitrary stable poles, and then performing the updating operations Q(lambda) leftarrow N_Q(lambda) and  R(lambda) leftarrow N_R(lambda). The stabilization via a left coprime factorization is usually performed as the last step of the synthesis procedures. ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For a detailed discussion of the coprime factorization based stabilization approach see Sections 7.6 and 10.4 of [1], where coprime factorization methods, based on recursive pole dislocation techniques are described, which produce directly the numerator factors N_Q(lambda) and N_R(lambda) (thus implicitly perform  the updating operations as well).","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For the solution of coprime factorizations, functions available in the DescriptorSystems package are employed. ","category":"page"},{"location":"SynthesisParadigms.html#References","page":"Synthesis paradigms","title":"References","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = FaultDetectionTools\nDocTestSetup = quote\n    using FaultDetectionTools\nend","category":"page"},{"location":"index.html#FaultDetectionTools.jl","page":"Home","title":"FaultDetectionTools.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The FaultDetectionTools.jl package (or shortlyFDITools) is a collection of Julia functions for the analysis and solution  of fault detection and isolation (FDI) problems. The functions of this collection rely on  the DescriptorSystems package [2], whose underlying computational functions are based on the MatrixPencils.jl [3] and MatrixEquations.jl [4] packages. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The implemented functions are based on the computational procedures described in Chapters 5, 6 and 7 of the book:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga, \"Solving Fault Diagnosis Problems, Linear Synthesis Techniques\", vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This book describes the mathematical background of solving synthesis problems of fault detection and model detection filters and gives detailed descriptions of the underlying synthesis procedures. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The targeted functionality parallels the functionality of the MATLAB collection of tools FDITOOLS, whose User's Guide of the version V1.0 is provided in the file fditoolsdoc.pdf.   Supplementary information on the targeted functionality is also available on arXiv in the documentation of the companion MATLAB FDITOOLS collection.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The available functions in the current version of the FaultDetectionTools.jl package are:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Building FDI related objects","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FDIModel  Fault detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDIFilter  Fault detection and isolation filter object.\nFDFilterIF  Fault detection filter internal form object.\nFDIFilterIF  Fault detection and isolation filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.\nfdIFeval  Evaluation of the internal forms of fault detection and isolation filters. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Analysis of FDI synthesis models","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fdigenspec  Generation of achievable FDI specifications.\nfdichkspec  Feasibility analysis of a set of FDI specifications.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Performance evaluation of FDI filters","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdiscond  Computation of the fault detection sensitivity condition.\nfdif2ngap  Computation of the fault-to-noise gap.\nfdimmperf  Computation of the model-matching performace.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solving FDI problems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"efdsyn  Exact synthesis of fault detection filters.\nefdisyn  Exact synthesis of fault detection and isolation filters.\nafdsyn  Approximate synthesis of fault detection filters.\nafdisyn  Approximate synthesis of fault detection and isolation filters.\nemmsyn  Exact model-matching based synthesis of fault detection filters.\nammsyn  Approximate model-matching based synthesis of fault detection filters.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FDI related computational utilities","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fdhinfminus  Evaluation of the H∞- index of the transfer function matrix of a descriptor system model.  \nfdhinfmax  Evaluation of the maximum of column norm of the transfer function matrix of a descriptor system model.  \nfditspec_  Computation of the weak or strong structure matrix of a descriptor system model.\nfdisspec_  Computation of the strong structure matrix of a descriptor system model.\nfdiscond_  Computation of the column-gains sensitivity condition of the transfer function matrix of a descriptor system model.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/FaultDetectionTools.jl/blob/master/ReleaseNotes.md)","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[2]  A. Varga, DescriptorSystems.jl: Manipulation of generalized state-space (descriptor) system representations. Zenodo: https://doi.org/10.5281/zenodo.5148319.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[4]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"}]
}
